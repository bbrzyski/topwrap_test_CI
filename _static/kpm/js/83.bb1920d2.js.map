{"version":3,"file":"js/83.bb1920d2.js","mappings":"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","sources":["webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/connection.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/defineNode.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/editor.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graph.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graphNode.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graphTemplate.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/node.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/nodeInterface.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/utils.js"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent } from \"@baklavajs/events\";\nexport class Connection {\n    constructor(from, to) {\n        this.destructed = false;\n        this.events = {\n            destruct: new BaklavaEvent(this),\n        };\n        if (!from || !to) {\n            throw new Error(\"Cannot initialize connection with null/undefined for 'from' or 'to' values\");\n        }\n        this.id = uuidv4();\n        this.from = from;\n        this.to = to;\n        this.from.connectionCount++;\n        this.to.connectionCount++;\n    }\n    destruct() {\n        this.events.destruct.emit();\n        this.from.connectionCount--;\n        this.to.connectionCount--;\n        this.destructed = true;\n    }\n}\n/**\n * This class is used for calculation purposes only.\n * It won't alter any state of the connected nodes\n */\nexport class DummyConnection {\n    constructor(from, to) {\n        if (!from || !to) {\n            throw new Error(\"Cannot initialize connection with null/undefined for 'from' or 'to' values\");\n        }\n        this.id = uuidv4();\n        this.from = from;\n        this.to = to;\n    }\n}\n","import { Node } from \"./node\";\nexport function defineNode(definition) {\n    return class extends Node {\n        constructor() {\n            var _a, _b;\n            super();\n            this.type = definition.type;\n            this.title = (_a = definition.title) !== null && _a !== void 0 ? _a : definition.type;\n            this.inputs = {};\n            this.outputs = {};\n            this.calculate = definition.calculate\n                ? (inputs, globalValues) => {\n                    return definition.calculate.call(this, inputs, globalValues);\n                }\n                : undefined;\n            this.executeFactory(\"input\", definition.inputs);\n            this.executeFactory(\"output\", definition.outputs);\n            (_b = definition.onCreate) === null || _b === void 0 ? void 0 : _b.call(this);\n        }\n        onPlaced() {\n            var _a;\n            (_a = definition.onPlaced) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        onDestroy() {\n            var _a;\n            (_a = definition.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        executeFactory(type, factory) {\n            Object.keys(factory || {}).forEach((k) => {\n                const intf = factory[k]();\n                if (type === \"input\") {\n                    this.addInput(k, intf);\n                }\n                else {\n                    this.addOutput(k, intf);\n                }\n            });\n        }\n    };\n}\n","import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, createProxy, } from \"@baklavajs/events\";\nimport { Graph } from \"./graph\";\nimport { createGraphNodeType, getGraphNodeTypeString } from \"./graphNode\";\nimport { GraphTemplate } from \"./graphTemplate\";\n/** The main model class for BaklavaJS */\nexport class Editor {\n    constructor() {\n        this.events = {\n            loaded: new BaklavaEvent(this),\n            beforeRegisterNodeType: new PreventableBaklavaEvent(this),\n            registerNodeType: new BaklavaEvent(this),\n            beforeUnregisterNodeType: new PreventableBaklavaEvent(this),\n            unregisterNodeType: new BaklavaEvent(this),\n            beforeAddGraphTemplate: new PreventableBaklavaEvent(this),\n            addGraphTemplate: new BaklavaEvent(this),\n            beforeRemoveGraphTemplate: new PreventableBaklavaEvent(this),\n            removeGraphTemplate: new BaklavaEvent(this),\n            registerGraph: new BaklavaEvent(this),\n            unregisterGraph: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            save: new SequentialHook(this),\n            load: new SequentialHook(this),\n        };\n        this.graphTemplateEvents = createProxy();\n        this.graphTemplateHooks = createProxy();\n        this.graphEvents = createProxy();\n        this.graphHooks = createProxy();\n        this.nodeEvents = createProxy();\n        this.nodeHooks = createProxy();\n        this.connectionEvents = createProxy();\n        this._graphs = new Set();\n        this._nodeTypes = new Map();\n        this._graph = new Graph(this);\n        this._graphTemplates = [];\n        this._loading = false;\n    }\n    /** List of all registered node types */\n    get nodeTypes() {\n        return this._nodeTypes;\n    }\n    /** The root graph */\n    get graph() {\n        return this._graph;\n    }\n    /** List of all registered graph templates (subgraphs) */\n    get graphTemplates() {\n        return this._graphTemplates;\n    }\n    /** Set of all graphs in the editor, including subgraphs */\n    get graphs() {\n        return this._graphs;\n    }\n    /** Whether the editor is currently in the process of loading a saved graph */\n    get loading() {\n        return this._loading;\n    }\n    /**\n     * Register a new node type\n     * @param type Actual type / constructor of the node\n     * @param options Optionally specify a title and/or a category for this node\n     */\n    registerNodeType(type, options) {\n        var _a, _b;\n        if (this.events.beforeRegisterNodeType.emit({ type, options }).prevented) {\n            return;\n        }\n        const nodeInstance = new type();\n        this._nodeTypes.set(nodeInstance.type, {\n            type,\n            category: (_a = options === null || options === void 0 ? void 0 : options.category) !== null && _a !== void 0 ? _a : \"default\",\n            title: (_b = options === null || options === void 0 ? void 0 : options.title) !== null && _b !== void 0 ? _b : nodeInstance.title,\n        });\n        this.events.registerNodeType.emit({ type, options });\n    }\n    /**\n     * Unregister an existing node type. Will also remove all the nodes of this type in all graphs.\n     * @param type String type or node constructor, from which the type will be detected\n     */\n    unregisterNodeType(type) {\n        const stringType = typeof type === \"string\" ? type : new type().type;\n        if (this.nodeTypes.has(stringType)) {\n            if (this.events.beforeUnregisterNodeType.emit(stringType).prevented) {\n                return;\n            }\n            this._nodeTypes.delete(stringType);\n            this.events.unregisterNodeType.emit(stringType);\n        }\n    }\n    addGraphTemplate(template) {\n        if (this.events.beforeAddGraphTemplate.emit(template).prevented) {\n            return;\n        }\n        this._graphTemplates.push(template);\n        this.graphTemplateEvents.addTarget(template.events);\n        this.graphTemplateHooks.addTarget(template.hooks);\n        const nt = createGraphNodeType(template);\n        this.registerNodeType(nt, { category: \"Subgraphs\", title: template.name });\n        this.events.addGraphTemplate.emit(template);\n    }\n    removeGraphTemplate(template) {\n        if (this.graphTemplates.includes(template)) {\n            if (this.events.beforeRemoveGraphTemplate.emit(template).prevented) {\n                return;\n            }\n            // remove all nodes of this type in all graphs\n            const graphNodeType = getGraphNodeTypeString(template);\n            for (const g of [this.graph, ...this.graphs.values()]) {\n                const nodesToRemove = g.nodes.filter((n) => n.type === graphNodeType);\n                for (const n of nodesToRemove) {\n                    g.removeNode(n);\n                }\n            }\n            this.unregisterNodeType(graphNodeType);\n            this._graphTemplates.splice(this._graphTemplates.indexOf(template), 1);\n            this.graphTemplateEvents.removeTarget(template.events);\n            this.graphTemplateHooks.removeTarget(template.hooks);\n            this.events.removeGraphTemplate.emit(template);\n        }\n    }\n    registerGraph(graph) {\n        this.graphEvents.addTarget(graph.events);\n        this.graphHooks.addTarget(graph.hooks);\n        this.nodeEvents.addTarget(graph.nodeEvents);\n        this.nodeHooks.addTarget(graph.nodeHooks);\n        this.connectionEvents.addTarget(graph.connectionEvents);\n        this.events.registerGraph.emit(graph);\n        this._graphs.add(graph);\n    }\n    unregisterGraph(graph) {\n        this.graphEvents.removeTarget(graph.events);\n        this.graphHooks.removeTarget(graph.hooks);\n        this.nodeEvents.removeTarget(graph.nodeEvents);\n        this.nodeHooks.removeTarget(graph.nodeHooks);\n        this.connectionEvents.removeTarget(graph.connectionEvents);\n        this.events.unregisterGraph.emit(graph);\n        this._graphs.delete(graph);\n    }\n    /**\n     * Load a state\n     * @param state State to load\n     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.\n     */\n    load(state) {\n        try {\n            this._loading = true;\n            state = this.hooks.load.execute(state);\n            state.graphTemplates.forEach((tState) => {\n                const template = new GraphTemplate(tState, this);\n                this.addGraphTemplate(template);\n            });\n            const warnings = this._graph.load(state.graph);\n            this.events.loaded.emit();\n            warnings.forEach((w) => console.warn(w));\n            return warnings;\n        }\n        finally {\n            this._loading = false;\n        }\n    }\n    /**\n     * Save a state\n     * @returns Current state\n     */\n    save() {\n        const state = {\n            graph: this.graph.save(),\n            graphTemplates: this.graphTemplates.map((t) => t.save()),\n        };\n        return this.hooks.save.execute(state);\n    }\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent, createProxy, PreventableBaklavaEvent, SequentialHook, ParallelHook, } from \"@baklavajs/events\";\nimport { Connection, DummyConnection } from \"./connection\";\nexport class Graph {\n    /** List of all nodes in this graph */\n    get nodes() {\n        return this._nodes;\n    }\n    /** List of all connections in this graph */\n    get connections() {\n        return this._connections;\n    }\n    /** Whether the graph is currently in the process of loading a saved graph */\n    get loading() {\n        return this._loading;\n    }\n    /** Whether the graph is currently in the process of destroying itself */\n    get destroying() {\n        return this._destroying;\n    }\n    constructor(editor, template) {\n        this.id = uuidv4();\n        this.inputs = [];\n        this.outputs = [];\n        this.activeTransactions = 0;\n        this._nodes = [];\n        this._connections = [];\n        this._loading = false;\n        this._destroying = false;\n        this.events = {\n            beforeAddNode: new PreventableBaklavaEvent(this),\n            addNode: new BaklavaEvent(this),\n            beforeRemoveNode: new PreventableBaklavaEvent(this),\n            removeNode: new BaklavaEvent(this),\n            beforeAddConnection: new PreventableBaklavaEvent(this),\n            addConnection: new BaklavaEvent(this),\n            checkConnection: new PreventableBaklavaEvent(this),\n            beforeRemoveConnection: new PreventableBaklavaEvent(this),\n            removeConnection: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            save: new SequentialHook(this),\n            load: new SequentialHook(this),\n            checkConnection: new ParallelHook(this),\n        };\n        this.nodeEvents = createProxy();\n        this.nodeHooks = createProxy();\n        this.connectionEvents = createProxy();\n        this.editor = editor;\n        this.template = template;\n        editor.registerGraph(this);\n    }\n    /**\n     * Add a node to the list of nodes.\n     * @param node Instance of a node\n     * @returns Instance of the node or undefined if the node was not added\n     */\n    addNode(node) {\n        if (this.events.beforeAddNode.emit(node).prevented) {\n            return;\n        }\n        this.nodeEvents.addTarget(node.events);\n        this.nodeHooks.addTarget(node.hooks);\n        node.registerGraph(this);\n        this._nodes.push(node);\n        // when adding the node to the array, it will be made reactive by Vue.\n        // However, our current reference is the non-reactive version.\n        // Therefore, we need to get the reactive version from the array.\n        node = this.nodes.find((n) => n.id === node.id);\n        node.onPlaced();\n        this.events.addNode.emit(node);\n        return node;\n    }\n    /**\n     * Removes a node from the list.\n     * Will also remove all connections from and to the node.\n     * @param node Reference to a node in the list.\n     */\n    removeNode(node) {\n        if (this.nodes.includes(node)) {\n            if (this.events.beforeRemoveNode.emit(node).prevented) {\n                return;\n            }\n            const interfaces = [...Object.values(node.inputs), ...Object.values(node.outputs)];\n            this.connections\n                .filter((c) => interfaces.includes(c.from) || interfaces.includes(c.to))\n                .forEach((c) => this.removeConnection(c));\n            this._nodes.splice(this.nodes.indexOf(node), 1);\n            this.events.removeNode.emit(node);\n            node.onDestroy();\n            this.nodeEvents.removeTarget(node.events);\n            this.nodeHooks.removeTarget(node.hooks);\n        }\n    }\n    /**\n     * Add a connection to the list of connections.\n     * @param from Start interface for the connection\n     * @param to Target interface for the connection\n     * @returns The created connection. If no connection could be created, returns `undefined`.\n     */\n    addConnection(from, to) {\n        const checkConnectionResult = this.checkConnection(from, to);\n        if (!checkConnectionResult.connectionAllowed) {\n            return undefined;\n        }\n        if (this.events.beforeAddConnection.emit({ from, to }).prevented) {\n            return;\n        }\n        for (const connectionToRemove of checkConnectionResult.connectionsInDanger) {\n            const instance = this.connections.find((c) => c.id === connectionToRemove.id);\n            if (instance) {\n                this.removeConnection(instance);\n            }\n        }\n        const c = new Connection(checkConnectionResult.dummyConnection.from, checkConnectionResult.dummyConnection.to);\n        this.internalAddConnection(c);\n        return c;\n    }\n    /**\n     * Remove a connection from the list of connections.\n     * @param connection Connection instance that should be removed.\n     */\n    removeConnection(connection) {\n        if (this.connections.includes(connection)) {\n            if (this.events.beforeRemoveConnection.emit(connection).prevented) {\n                return;\n            }\n            connection.destruct();\n            this._connections.splice(this.connections.indexOf(connection), 1);\n            this.events.removeConnection.emit(connection);\n            this.connectionEvents.removeTarget(connection.events);\n        }\n    }\n    /**\n     * Checks, whether a connection between two node interfaces would be valid.\n     * @param from The starting node interface (must be an output interface)\n     * @param to The target node interface (must be an input interface)\n     * @returns Whether the connection is allowed or not.\n     */\n    checkConnection(from, to) {\n        if (!from || !to) {\n            return { connectionAllowed: false };\n        }\n        const fromNode = this.findNodeById(from.nodeId);\n        const toNode = this.findNodeById(to.nodeId);\n        if (fromNode && toNode && fromNode === toNode) {\n            // connections must be between two separate nodes.\n            return { connectionAllowed: false };\n        }\n        if (from.isInput && !to.isInput) {\n            // reverse connection\n            const tmp = from;\n            from = to;\n            to = tmp;\n        }\n        if (from.isInput || !to.isInput) {\n            // connections are only allowed from input to output interface\n            return { connectionAllowed: false };\n        }\n        // prevent duplicate connections\n        if (this.connections.some((c) => c.from === from && c.to === to)) {\n            return { connectionAllowed: false };\n        }\n        if (this.events.checkConnection.emit({ from, to }).prevented) {\n            return { connectionAllowed: false };\n        }\n        const hookResults = this.hooks.checkConnection.execute({ from, to });\n        if (hookResults.some((hr) => !hr.connectionAllowed)) {\n            return { connectionAllowed: false };\n        }\n        const connectionsInDanger = Array.from(new Set(hookResults.flatMap((hr) => hr.connectionsInDanger)));\n        return {\n            connectionAllowed: true,\n            dummyConnection: new DummyConnection(from, to),\n            connectionsInDanger,\n        };\n    }\n    /**\n     * Finds the NodeInterface with the provided id, as long as it exists in this graph\n     * @param id id of the NodeInterface to find\n     * @returns The NodeInterface if found, otherwise undefined\n     */\n    findNodeInterface(id) {\n        for (const node of this.nodes) {\n            for (const k in node.inputs) {\n                const nodeInput = node.inputs[k];\n                if (nodeInput.id === id) {\n                    return nodeInput;\n                }\n            }\n            for (const k in node.outputs) {\n                const nodeOutput = node.outputs[k];\n                if (nodeOutput.id === id) {\n                    return nodeOutput;\n                }\n            }\n        }\n    }\n    /**\n     * Finds the Node with the provided id, as long as it exists in this graph\n     * @param id id of the Node to find\n     * @returns The Node if found, otherwise undefined\n     */\n    findNodeById(id) {\n        return this.nodes.find((n) => n.id === id);\n    }\n    /**\n     * Load a state\n     * @param state State to load\n     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.\n     */\n    load(state) {\n        try {\n            this._loading = true;\n            const warnings = [];\n            // Clear current state\n            for (let i = this.connections.length - 1; i >= 0; i--) {\n                this.removeConnection(this.connections[i]);\n            }\n            for (let i = this.nodes.length - 1; i >= 0; i--) {\n                this.removeNode(this.nodes[i]);\n            }\n            // Load state\n            this.id = state.id;\n            this.inputs = state.inputs;\n            this.outputs = state.outputs;\n            for (const n of state.nodes) {\n                // find node type\n                const nodeInformation = this.editor.nodeTypes.get(n.type);\n                if (!nodeInformation) {\n                    warnings.push(`Node type ${n.type} is not registered`);\n                    continue;\n                }\n                const node = new nodeInformation.type();\n                this.addNode(node);\n                node.load(n);\n            }\n            for (const c of state.connections) {\n                const fromIf = this.findNodeInterface(c.from);\n                const toIf = this.findNodeInterface(c.to);\n                if (!fromIf) {\n                    warnings.push(`Could not find interface with id ${c.from}`);\n                    continue;\n                }\n                else if (!toIf) {\n                    warnings.push(`Could not find interface with id ${c.to}`);\n                    continue;\n                }\n                else {\n                    const conn = new Connection(fromIf, toIf);\n                    conn.id = c.id;\n                    this.internalAddConnection(conn);\n                }\n            }\n            this.hooks.load.execute(state);\n            return warnings;\n        }\n        finally {\n            this._loading = false;\n        }\n    }\n    /**\n     * Save a state\n     * @returns Current state\n     */\n    save() {\n        const state = {\n            id: this.id,\n            nodes: this.nodes.map((n) => n.save()),\n            connections: this.connections.map((c) => ({\n                id: c.id,\n                from: c.from.id,\n                to: c.to.id,\n            })),\n            inputs: this.inputs,\n            outputs: this.outputs,\n        };\n        return this.hooks.save.execute(state);\n    }\n    destroy() {\n        this._destroying = true;\n        for (const n of this.nodes) {\n            this.removeNode(n);\n        }\n        this.editor.unregisterGraph(this);\n    }\n    internalAddConnection(c) {\n        this.connectionEvents.addTarget(c.events);\n        this._connections.push(c);\n        this.events.addConnection.emit(c);\n    }\n}\n","import { AbstractNode } from \"./node\";\nimport { NodeInterface } from \"./nodeInterface\";\nexport const GRAPH_NODE_TYPE_PREFIX = \"__baklava_GraphNode-\";\nexport function getGraphNodeTypeString(template) {\n    return GRAPH_NODE_TYPE_PREFIX + template.id;\n}\nexport function createGraphNodeType(template) {\n    return class GraphNode extends AbstractNode {\n        constructor() {\n            super(...arguments);\n            this.type = getGraphNodeTypeString(template);\n            this._title = \"GraphNode\";\n            this.inputs = {};\n            this.outputs = {};\n            this.template = template;\n            this.calculate = async (inputs, context) => {\n                if (!this.subgraph) {\n                    throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`);\n                }\n                if (typeof context.engine === \"object\" &&\n                    !!context.engine &&\n                    typeof context.engine.runGraph === \"function\") {\n                    const graphInputs = new Map();\n                    // gather all values of the unconnected inputs\n                    for (const n of this.subgraph.nodes) {\n                        Object.values(n.inputs).forEach((ni) => {\n                            if (ni.connectionCount === 0) {\n                                graphInputs.set(ni.id, ni.value);\n                            }\n                        });\n                    }\n                    // map graph inputs to their respective nodeInterfaceId in the graph\n                    Object.entries(inputs).forEach(([k, v]) => {\n                        const gi = this.subgraph.inputs.find((x) => x.id === k);\n                        graphInputs.set(gi.nodeInterfaceId, v);\n                    });\n                    const result = await context.engine.runGraph(this.subgraph, graphInputs, context.globalValues);\n                    const flatResult = new Map();\n                    result.forEach((nodeOutputs, nodeId) => {\n                        const node = this.subgraph.nodes.find((n) => n.id === nodeId);\n                        nodeOutputs.forEach((v, nodeInterfaceKey) => {\n                            flatResult.set(node.outputs[nodeInterfaceKey].id, v);\n                        });\n                    });\n                    const outputs = {};\n                    this.subgraph.outputs.forEach((graphOutput) => {\n                        outputs[graphOutput.id] = flatResult.get(graphOutput.nodeInterfaceId);\n                    });\n                    outputs._calculationResults = result;\n                    return outputs;\n                }\n            };\n        }\n        get title() {\n            return this._title;\n        }\n        set title(v) {\n            this.template.name = v;\n        }\n        load(state) {\n            if (!this.subgraph) {\n                throw new Error(\"Cannot load a graph node without a graph\");\n            }\n            if (!this.template) {\n                throw new Error(\"Unable to load graph node without graph template\");\n            }\n            this.subgraph.load(state.graphState);\n            super.load(state);\n        }\n        save() {\n            if (!this.subgraph) {\n                throw new Error(\"Cannot save a graph node without a graph\");\n            }\n            const state = super.save();\n            return {\n                ...state,\n                graphState: this.subgraph.save(),\n            };\n        }\n        onPlaced() {\n            this.template.events.updated.subscribe(this, () => this.initialize());\n            this.template.events.nameChanged.subscribe(this, (name) => {\n                this._title = name;\n            });\n            this.initialize();\n        }\n        onDestroy() {\n            var _a;\n            this.template.events.updated.unsubscribe(this);\n            this.template.events.nameChanged.unsubscribe(this);\n            (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.destroy();\n        }\n        initialize() {\n            if (this.subgraph) {\n                this.subgraph.destroy();\n            }\n            this.subgraph = this.template.createGraph();\n            this._title = this.template.name;\n            this.updateInterfaces();\n            this.events.update.emit(null);\n        }\n        updateInterfaces() {\n            if (!this.subgraph) {\n                throw new Error(\"Trying to update interfaces without graph instance\");\n            }\n            for (const graphInput of this.subgraph.inputs) {\n                if (!(graphInput.id in this.inputs)) {\n                    this.addInput(graphInput.id, new NodeInterface(graphInput.name, undefined));\n                }\n                else {\n                    this.inputs[graphInput.id].name = graphInput.name;\n                }\n            }\n            for (const k of Object.keys(this.inputs)) {\n                if (!this.subgraph.inputs.some((gi) => gi.id === k)) {\n                    this.removeInput(k);\n                }\n            }\n            for (const graphOutput of this.subgraph.outputs) {\n                if (!(graphOutput.id in this.outputs)) {\n                    this.addOutput(graphOutput.id, new NodeInterface(graphOutput.name, undefined));\n                }\n                else {\n                    this.outputs[graphOutput.id].name = graphOutput.name;\n                }\n            }\n            for (const k of Object.keys(this.outputs)) {\n                if (!this.subgraph.outputs.some((gi) => gi.id === k)) {\n                    this.removeOutput(k);\n                }\n            }\n            // Add an internal output to allow accessing the calculation results of nodes inside the graph\n            this.addOutput(\"_calculationResults\", new NodeInterface(\"_calculationResults\", undefined).setHidden(true));\n        }\n    };\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent, SequentialHook } from \"@baklavajs/events\";\nimport { Graph } from \"./graph\";\nimport { mapValues } from \"./utils\";\nimport { getGraphNodeTypeString } from \"./graphNode\";\nexport class GraphTemplate {\n    /** Create a new GraphTemplate from the nodes and connections inside the graph instance */\n    static fromGraph(graph, editor) {\n        return new GraphTemplate(graph.save(), editor);\n    }\n    /** Get the name of the graph template */\n    get name() {\n        return this._name;\n    }\n    /** Set the name of the graph template */\n    set name(v) {\n        this._name = v;\n        this.events.nameChanged.emit(v);\n        const nt = this.editor.nodeTypes.get(getGraphNodeTypeString(this));\n        if (nt) {\n            nt.title = v;\n        }\n    }\n    constructor(state, editor) {\n        /** Graph template id */\n        this.id = uuidv4();\n        this._name = \"Subgraph\";\n        this.events = {\n            nameChanged: new BaklavaEvent(this),\n            updated: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            beforeLoad: new SequentialHook(this),\n            afterSave: new SequentialHook(this),\n        };\n        this.editor = editor;\n        if (state.id) {\n            this.id = state.id;\n        }\n        if (state.name) {\n            this._name = state.name;\n        }\n        this.update(state);\n    }\n    /** Update the state of the graph template with the provided state */\n    update(state) {\n        this.nodes = state.nodes;\n        this.connections = state.connections;\n        this.inputs = state.inputs;\n        this.outputs = state.outputs;\n        this.events.updated.emit();\n    }\n    save() {\n        return {\n            id: this.id,\n            name: this.name,\n            nodes: this.nodes,\n            connections: this.connections,\n            inputs: this.inputs,\n            outputs: this.outputs,\n        };\n    }\n    /**\n     * Create a new graph instance from this template\n     * or load the state into the provided graph instance.\n     */\n    createGraph(graph) {\n        const idMap = new Map();\n        const createNewId = (oldId) => {\n            const newId = uuidv4();\n            idMap.set(oldId, newId);\n            return newId;\n        };\n        const getNewId = (oldId) => {\n            const newId = idMap.get(oldId);\n            if (!newId) {\n                throw new Error(`Unable to create graph from template: Could not map old id ${oldId} to new id`);\n            }\n            return newId;\n        };\n        const mapNodeInterfaceIds = (interfaceStates) => {\n            return mapValues(interfaceStates, (intf) => {\n                const clonedIntf = {\n                    id: createNewId(intf.id),\n                    templateId: intf.id,\n                    value: intf.value,\n                };\n                return clonedIntf;\n            });\n        };\n        const nodes = this.nodes.map((n) => ({\n            ...n,\n            id: createNewId(n.id),\n            inputs: mapNodeInterfaceIds(n.inputs),\n            outputs: mapNodeInterfaceIds(n.outputs),\n        }));\n        const connections = this.connections.map((c) => ({\n            id: createNewId(c.id),\n            from: getNewId(c.from),\n            to: getNewId(c.to),\n        }));\n        const inputs = this.inputs.map((i) => ({\n            id: i.id,\n            name: i.name,\n            nodeInterfaceId: getNewId(i.nodeInterfaceId),\n        }));\n        const outputs = this.outputs.map((o) => ({\n            id: o.id,\n            name: o.name,\n            nodeInterfaceId: getNewId(o.nodeInterfaceId),\n        }));\n        const clonedState = {\n            id: uuidv4(),\n            nodes,\n            connections,\n            inputs,\n            outputs,\n        };\n        if (!graph) {\n            graph = new Graph(this.editor);\n        }\n        graph.load(clonedState);\n        graph.template = this;\n        return graph;\n    }\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, } from \"@baklavajs/events\";\nimport { mapValues } from \"./utils\";\nexport class AbstractNode {\n    constructor() {\n        /** Unique identifier of the node */\n        this.id = uuidv4();\n        this.events = {\n            loaded: new BaklavaEvent(this),\n            beforeAddInput: new PreventableBaklavaEvent(this),\n            addInput: new BaklavaEvent(this),\n            beforeRemoveInput: new PreventableBaklavaEvent(this),\n            removeInput: new BaklavaEvent(this),\n            beforeAddOutput: new PreventableBaklavaEvent(this),\n            addOutput: new BaklavaEvent(this),\n            beforeRemoveOutput: new PreventableBaklavaEvent(this),\n            removeOutput: new BaklavaEvent(this),\n            update: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            beforeLoad: new SequentialHook(this),\n            afterSave: new SequentialHook(this),\n        };\n    }\n    /**\n     * The graph instance the node is placed in.\n     * `undefined` if the node hasn't been placed in a graph yet.\n     */\n    get graph() {\n        return this.graphInstance;\n    }\n    /**\n     * Add an input interface to the node\n     * @param key Key of the input\n     * @param input The input instance\n     * @returns True when the input was added, otherwise false (prevented by an event handler)\n     */\n    addInput(key, input) {\n        return this.addInterface(\"input\", key, input);\n    }\n    /**\n     * Add an output interface to the node\n     * @param key Key of the output\n     * @param output The output instance\n     * @returns True when the output was added, otherwise false (prevented by an event handler)\n     */\n    addOutput(key, output) {\n        return this.addInterface(\"output\", key, output);\n    }\n    /**\n     * Remove an existing input\n     * @param key Key of the input.\n     */\n    removeInput(key) {\n        return this.removeInterface(\"input\", key);\n    }\n    /**\n     * Remove an existing output\n     * @param key Key of the output.\n     */\n    removeOutput(key) {\n        return this.removeInterface(\"output\", key);\n    }\n    /**\n     * This function will automatically be called as soon as the node is added to a graph.\n     * @param editor Graph instance\n     */\n    registerGraph(graph) {\n        this.graphInstance = graph;\n    }\n    load(state) {\n        this.hooks.beforeLoad.execute(state);\n        this.id = state.id;\n        this.title = state.title;\n        Object.entries(state.inputs).forEach(([k, v]) => {\n            if (this.inputs[k]) {\n                this.inputs[k].load(v);\n                this.inputs[k].nodeId = this.id;\n            }\n        });\n        Object.entries(state.outputs).forEach(([k, v]) => {\n            if (this.outputs[k]) {\n                this.outputs[k].load(v);\n                this.outputs[k].nodeId = this.id;\n            }\n        });\n        this.events.loaded.emit(this);\n    }\n    save() {\n        const inputStates = mapValues(this.inputs, (intf) => intf.save());\n        const outputStates = mapValues(this.outputs, (intf) => intf.save());\n        const state = {\n            type: this.type,\n            id: this.id,\n            title: this.title,\n            inputs: inputStates,\n            outputs: outputStates,\n        };\n        return this.hooks.afterSave.execute(state);\n    }\n    /**\n     * @virtual\n     * Override this method to execute logic when the node is placed inside a graph\n     */\n    onPlaced() { }\n    /**\n     * @virtual\n     * Override this method to perform cleanup when the node is deleted\n     */\n    onDestroy() { }\n    initializeIo() {\n        Object.entries(this.inputs).forEach(([key, intf]) => this.initializeIntf(\"input\", key, intf));\n        Object.entries(this.outputs).forEach(([key, intf]) => this.initializeIntf(\"output\", key, intf));\n    }\n    initializeIntf(type, key, intf) {\n        intf.isInput = type === \"input\";\n        intf.nodeId = this.id;\n        intf.events.setValue.subscribe(this, () => this.events.update.emit({ type, name: key, intf }));\n    }\n    addInterface(type, key, intf) {\n        const beforeEvent = type === \"input\" ? this.events.beforeAddInput : this.events.beforeAddOutput;\n        const afterEvent = type === \"input\" ? this.events.addInput : this.events.addOutput;\n        const ioObject = type === \"input\" ? this.inputs : this.outputs;\n        if (beforeEvent.emit(intf).prevented) {\n            return false;\n        }\n        ioObject[key] = intf;\n        this.initializeIntf(type, key, intf);\n        afterEvent.emit(intf);\n        return true;\n    }\n    removeInterface(type, key) {\n        const beforeEvent = type === \"input\" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput;\n        const afterEvent = type === \"input\" ? this.events.removeInput : this.events.removeOutput;\n        const io = type === \"input\" ? this.inputs[key] : this.outputs[key];\n        if (!io || beforeEvent.emit(io).prevented) {\n            return false;\n        }\n        if (io.connectionCount > 0) {\n            if (this.graphInstance) {\n                const connections = this.graphInstance.connections.filter((c) => c.from === io || c.to === io);\n                connections.forEach((c) => {\n                    this.graphInstance.removeConnection(c);\n                });\n            }\n            else {\n                throw new Error(\"Interface is connected, but no graph instance is specified. Unable to delete interface\");\n            }\n        }\n        io.events.setValue.unsubscribe(this);\n        if (type === \"input\") {\n            delete this.inputs[key];\n        }\n        else {\n            delete this.outputs[key];\n        }\n        afterEvent.emit(io);\n        return true;\n    }\n}\n/**\n * Abstract base class for every node\n */\nexport class Node extends AbstractNode {\n    load(state) {\n        super.load(state);\n    }\n    save() {\n        return super.save();\n    }\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { SequentialHook, BaklavaEvent, PreventableBaklavaEvent, } from \"@baklavajs/events\";\nexport class NodeInterface {\n    set connectionCount(v) {\n        this._connectionCount = v;\n        this.events.setConnectionCount.emit(v);\n    }\n    get connectionCount() {\n        return this._connectionCount;\n    }\n    set value(v) {\n        if (this.events.beforeSetValue.emit(v).prevented) {\n            return;\n        }\n        this._value = v;\n        this.events.setValue.emit(v);\n    }\n    get value() {\n        return this._value;\n    }\n    constructor(name, value) {\n        this.id = uuidv4();\n        /** Id of the node this interface is part of */\n        this.nodeId = \"\";\n        /** Whether to show the port (the thing connections connect to) */\n        this.port = true;\n        /** Whether to hide the node interface in the UI */\n        this.hidden = false;\n        this.events = {\n            setConnectionCount: new BaklavaEvent(this),\n            beforeSetValue: new PreventableBaklavaEvent(this),\n            setValue: new BaklavaEvent(this),\n            updated: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            load: new SequentialHook(this),\n            save: new SequentialHook(this),\n        };\n        this._connectionCount = 0;\n        this.name = name;\n        this._value = value;\n    }\n    load(state) {\n        this.id = state.id;\n        this.templateId = state.templateId;\n        this.value = state.value;\n        this.hooks.load.execute(state);\n    }\n    save() {\n        const state = {\n            id: this.id,\n            templateId: this.templateId,\n            value: this.value,\n        };\n        return this.hooks.save.execute(state);\n    }\n    setComponent(value) {\n        this.component = value;\n        return this;\n    }\n    setPort(value) {\n        this.port = value;\n        return this;\n    }\n    setHidden(value) {\n        this.hidden = value;\n        return this;\n    }\n    use(middleware, ...args) {\n        middleware(this, ...args);\n        return this;\n    }\n}\n","/** Key type is limited due to https://github.com/microsoft/TypeScript/pull/37457 */\nexport function mapValues(obj, fn) {\n    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));\n}\n"],"names":["Connection","constructor","from","to","this","destructed","events","destruct","Error","id","connectionCount","emit","DummyConnection","defineNode","definition","N","_a","_b","super","type","title","inputs","outputs","calculate","globalValues","call","undefined","executeFactory","onCreate","onPlaced","onDestroy","factory","Object","keys","forEach","k","intf","addInput","addOutput","Editor","loaded","beforeRegisterNodeType","registerNodeType","beforeUnregisterNodeType","unregisterNodeType","beforeAddGraphTemplate","addGraphTemplate","beforeRemoveGraphTemplate","removeGraphTemplate","registerGraph","unregisterGraph","hooks","save","load","graphTemplateEvents","graphTemplateHooks","graphEvents","graphHooks","nodeEvents","nodeHooks","connectionEvents","_graphs","Set","_nodeTypes","Map","_graph","_graphTemplates","_loading","nodeTypes","graph","graphTemplates","graphs","loading","options","prevented","nodeInstance","set","category","stringType","has","delete","template","push","addTarget","nt","name","includes","graphNodeType","g","values","nodesToRemove","nodes","filter","n","removeNode","splice","indexOf","removeTarget","add","state","execute","tState","warnings","w","console","warn","map","t","Graph","_nodes","connections","_connections","destroying","_destroying","editor","activeTransactions","beforeAddNode","addNode","beforeRemoveNode","beforeAddConnection","addConnection","checkConnection","beforeRemoveConnection","removeConnection","node","find","interfaces","c","checkConnectionResult","connectionAllowed","connectionToRemove","connectionsInDanger","instance","dummyConnection","internalAddConnection","connection","fromNode","findNodeById","nodeId","toNode","isInput","tmp","some","hookResults","hr","Array","flatMap","findNodeInterface","nodeInput","nodeOutput","i","length","nodeInformation","get","fromIf","toIf","conn","destroy","GRAPH_NODE_TYPE_PREFIX","getGraphNodeTypeString","createGraphNodeType","arguments","_title","async","context","subgraph","engine","runGraph","graphInputs","ni","value","entries","v","gi","x","nodeInterfaceId","result","flatResult","nodeOutputs","nodeInterfaceKey","graphOutput","_calculationResults","graphState","updated","subscribe","initialize","nameChanged","unsubscribe","createGraph","updateInterfaces","update","graphInput","removeInput","removeOutput","setHidden","GraphTemplate","static","_name","beforeLoad","afterSave","idMap","createNewId","oldId","newId","getNewId","mapNodeInterfaceIds","interfaceStates","templateId","o","clonedState","AbstractNode","beforeAddInput","beforeRemoveInput","beforeAddOutput","beforeRemoveOutput","graphInstance","key","input","addInterface","output","removeInterface","inputStates","outputStates","initializeIo","initializeIntf","setValue","beforeEvent","afterEvent","ioObject","io","Node","NodeInterface","_connectionCount","setConnectionCount","beforeSetValue","_value","port","hidden","setComponent","component","setPort","use","middleware","args","mapValues","obj","fn","fromEntries"],"sourceRoot":""}