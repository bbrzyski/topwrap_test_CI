{"version":3,"file":"js/index-a5943e60.261d23dd.js","mappings":"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","sources":["webpack://pipeline-manager/./src/core/History.ts","webpack://pipeline-manager/./src/core/communication/runInformation.ts","webpack://pipeline-manager/./src/core/interfaceRegistry.ts","webpack://pipeline-manager/./src/core/snappers.ts","webpack://pipeline-manager/./src/core/Clipboard.ts","webpack://pipeline-manager/./src/core/InterfaceTypes.js","webpack://pipeline-manager/./src/core/ConnectionRenderer.js","webpack://pipeline-manager/./src/core/Specification.js","webpack://pipeline-manager/./src/core/EditorManager.js","webpack://pipeline-manager/./src/core/layoutEngines/baseEngine.js","webpack://pipeline-manager/./src/core/layoutEngines/cytoscapeEngine.js","webpack://pipeline-manager/./src/core/layoutEngines/noLayoutEngine.js","webpack://pipeline-manager/./src/core/LayoutManager.js","webpack://pipeline-manager/./src/core/NodeFactory.js","webpack://pipeline-manager/./src/core/utils.ts","webpack://pipeline-manager/./src/core/communication/remoteProcedures.ts","webpack://pipeline-manager/./src/core/communication/rpcCommunication.ts","webpack://pipeline-manager/./src/core/communication/ExternalApplicationManager.js","webpack://pipeline-manager/./src/core/doubleClick.js","webpack://pipeline-manager/./src/core/events.js","webpack://pipeline-manager/./src/core/interfaceParser.js","webpack://pipeline-manager/./src/core/notifications.js","webpack://pipeline-manager/./src/core/stores.js"],"sourcesContent":["/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable max-classes-per-file */\nimport { reactive, ref, watch, } from 'vue';\nimport { v4 as uuidv4 } from 'uuid';\nexport const suppressingHistory = ref(false);\nconst transactionId = ref('');\nexport class Step {\n    constructor(type, topic, tid = uuidv4()) {\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"transactionId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // I need this to be of basically any type, as\n        // it may need to receive objects, arrays of objects, other steps\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        Object.defineProperty(this, \"topic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.type = type;\n        this.topic = topic;\n        this.transactionId = tid;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    add(graph) {\n        throw new Error(`Method add has thrown an error for topic: ${this.topic}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    remove(graph) {\n        throw new Error(`Method remove has thrown an error for topic: ${this.topic}`);\n    }\n}\nclass NodeStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"nodeTuple\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    add(graph) {\n        if (this.nodeTuple[0] !== undefined) {\n            const n = graph.value.addNode(this.nodeTuple[0]);\n            n.load(this.nodeTuple[1]);\n        }\n    }\n    remove(graph) {\n        const node = graph.value.nodes.find((n) => n.id === this.topic);\n        if (node !== undefined) {\n            this.nodeTuple = [node, node.save()];\n            graph.value.removeNode(node);\n        }\n    }\n}\nclass ConnectionStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"conn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    add(graph) {\n        if (this.conn !== undefined) {\n            // The object of the interfaces itself has changed and despite\n            // having all the same fields, it will not assign the connection\n            // correctly. That's why it is necessary to extract the nodeId\n            // from what we have and find the interface in said node manually\n            const fromNode = graph.value.findNodeById(this.conn.from.nodeId);\n            const toNode = graph.value.findNodeById(this.conn.to.nodeId);\n            if (!fromNode || !toNode)\n                return;\n            const from = [\n                ...Object.values(fromNode.inputs),\n                ...Object.values(fromNode.outputs),\n            ].filter((iface) => iface.port).find((iface) => iface.id === this.conn.from.id);\n            const to = [\n                ...Object.values(toNode.inputs),\n                ...Object.values(toNode.outputs),\n            ].filter((iface) => iface.port).find((iface) => iface.id === this.conn.to.id);\n            if (!from || !to)\n                return;\n            const connAdded = graph.value.addConnection(from, to);\n            if (connAdded === undefined) {\n                return;\n            }\n            connAdded.id = this.conn.id;\n        }\n    }\n    remove(graph) {\n        const conn = graph.value.connections.find((n) => n.id === this.topic);\n        if (conn !== undefined) {\n            this.conn = conn;\n            graph.value.removeConnection(conn);\n        }\n    }\n}\nclass AnchorStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"anchor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    add(graph) {\n        if (this.anchor !== undefined) {\n            const conn = graph.value.connections.find((n) => n.from.id === this.anchor[0].from.id &&\n                n.to.id === this.anchor[0].to.id &&\n                n.id === this.anchor[0].id);\n            if (conn !== undefined)\n                if (conn.anchors === undefined)\n                    conn.anchors = [];\n            conn.anchors.splice(this.anchor[2], 0, this.anchor[1]);\n        }\n    }\n    remove(graph) {\n        if (this.anchor !== undefined) {\n            const conn = graph.value.connections.find((n) => n.from === this.anchor[0].from && n.to === this.anchor[0].to);\n            if (conn !== undefined)\n                conn.anchors.splice(this.anchor[2], 1);\n        }\n    }\n}\nexport function suppressHistoryLogging(value) {\n    suppressingHistory.value = value;\n}\nexport function startTransaction(id = uuidv4()) {\n    if (transactionId.value !== '')\n        return undefined;\n    transactionId.value = id;\n    return id;\n}\nexport function commitTransaction() {\n    transactionId.value = '';\n}\nexport function useHistory(graph, commandHandler) {\n    const token = Symbol('CustomHistoryToken');\n    const maxSteps = 200;\n    const history = new Map();\n    const undoneHistory = new Map();\n    let currentId = 'ThisShouldNotAppearInHistoryMaps';\n    let oldId = 'ThisShouldNotAppearInHistoryMaps';\n    const unsubscribeFromGraphEvents = (g, tok) => {\n        g.events.addNode.unsubscribe(tok);\n        g.events.removeNode.unsubscribe(tok);\n        g.events.addConnection.unsubscribe(tok);\n        g.events.removeConnection.unsubscribe(tok);\n        g.events.addAnchor.unsubscribe(tok);\n        g.events.removeAnchor.unsubscribe(tok);\n    };\n    // Switch all the events to any new graph that's displayed\n    const graphSwitch = (newGraph, oldGraph, copyStateStack = false) => {\n        if (oldGraph) {\n            unsubscribeFromGraphEvents(oldGraph, token);\n        }\n        if (newGraph) {\n            oldId = currentId;\n            currentId = newGraph.id;\n            if (history.get(currentId) === undefined)\n                history.set(currentId, []);\n            if (undoneHistory.get(currentId) === undefined)\n                undoneHistory.set(currentId, []);\n            if (copyStateStack) {\n                const undoneItem = undoneHistory.get(oldId);\n                if (undoneItem)\n                    undoneHistory.set(currentId, undoneItem);\n                const historyItem = history.get(oldId);\n                if (historyItem)\n                    history.set(currentId, historyItem);\n            }\n            newGraph.events.addNode.subscribe(token, (node) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    historyItem.push(new NodeStep('add', node.id.toString(), transactionId.value));\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeNode.subscribe(token, (node) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const step = new NodeStep('rem', node.id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.nodeTuple = [node, node.save()];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.addConnection.subscribe(token, (conn) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    historyItem.push(new ConnectionStep('add', conn.id.toString(), transactionId.value));\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeConnection.subscribe(token, (conn) => {\n                var _a;\n                if (!suppressingHistory.value) {\n                    const inTransaction = transactionId.value !== '';\n                    if (!inTransaction)\n                        startTransaction();\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    ((_a = conn.anchors) !== null && _a !== void 0 ? _a : []).slice().reverse().forEach((anchor) => {\n                        newGraph.events.removeAnchor.emit([conn, conn.anchors.indexOf(anchor)]);\n                    });\n                    const step = new ConnectionStep('rem', conn.id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.conn = conn;\n                    undoneHistory.set(newGraph.id, []);\n                    if (!inTransaction)\n                        commitTransaction();\n                }\n            });\n            newGraph.events.addAnchor.subscribe(token, (tuple) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const idx = Math.trunc((tuple[1] - 1) / 3);\n                    const conn = tuple[0];\n                    const step = new AnchorStep('add', conn.anchors[idx].id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.anchor = [conn, conn.anchors[idx], idx];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeAnchor.subscribe(token, (tuple) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const idx = tuple[1];\n                    const conn = tuple[0];\n                    const step = new AnchorStep('rem', conn.anchors[idx].id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.anchor = [conn, conn.anchors[idx], idx];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n        }\n    };\n    watch(graph, (newGraph, oldGraph) => graphSwitch(newGraph, oldGraph), { flush: 'post', immediate: true });\n    const singleStepTransaction = (mainHistory, auxiliaryHistory) => {\n        const step = mainHistory.pop();\n        if (step === undefined)\n            return;\n        suppressingHistory.value = true;\n        if (step.type === 'add') {\n            step.type = 'rem';\n            step.remove(graph);\n        }\n        else if (step.type === 'rem') {\n            step.type = 'add';\n            step.add(graph);\n        }\n        auxiliaryHistory.push(step);\n        if (mainHistory.length > 0 &&\n            mainHistory[mainHistory.length - 1].transactionId === step.transactionId)\n            singleStepTransaction(mainHistory, auxiliaryHistory);\n        suppressingHistory.value = false;\n        graph.value.selectedNodes.splice(0, graph.value.selectedNodes.length);\n    };\n    commandHandler.registerCommand('undo', {\n        canExecute: () => true,\n        execute: () => {\n            const historyItem = history.get(currentId);\n            if (historyItem && historyItem.length !== 0) {\n                const undoneItem = undoneHistory.get(currentId);\n                if (historyItem && undoneItem)\n                    singleStepTransaction(historyItem, undoneItem);\n            }\n        },\n    });\n    commandHandler.registerCommand('redo', {\n        canExecute: () => true,\n        execute: () => {\n            const historyItem = history.get(currentId);\n            const undoneItem = undoneHistory.get(currentId);\n            if (historyItem && undoneItem && undoneItem.length !== 0) {\n                singleStepTransaction(undoneItem, historyItem);\n            }\n        },\n    });\n    commandHandler.registerCommand('START_TRANSACTION', {\n        canExecute: () => transactionId.value === '',\n        execute: () => startTransaction,\n    });\n    commandHandler.registerCommand('COMMIT_TRANSACTION', {\n        canExecute: () => transactionId.value !== '',\n        execute: () => commitTransaction,\n    });\n    commandHandler.registerHotkey(['Control', 'z'], 'undo');\n    commandHandler.registerHotkey(['Control', 'y'], 'redo');\n    return reactive({\n        max_steps: maxSteps,\n        graphSwitch,\n        unsubscribeFromGraphEvents,\n    });\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable max-classes-per-file */\n/**\n * Class with information about ran procedure.\n */\nclass RunInfo {\n    /**\n     * @param procedureName Name of the procedure\n     */\n    constructor(procedureName) {\n        Object.defineProperty(this, \"procedureName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        /** @private */\n        Object.defineProperty(this, \"pr_inProgress\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.procedureName = procedureName;\n    }\n    /**\n     * Finds progress bar affiliated with run.\n     * If cannot be found, throws Error.\n     */\n    get progressBar() {\n        const progressBar = document.querySelector(`#navbar-button-${this.procedureName} > .progress-bar`);\n        return progressBar;\n    }\n    /**\n     * Specifies if run is in progress.\n     */\n    get inProgress() {\n        return this.pr_inProgress;\n    }\n    set inProgress(value) {\n        const { progressBar } = this;\n        if (progressBar) {\n            if (!value)\n                progressBar.classList.remove('animate');\n            progressBar.style.width = '0%';\n        }\n        this.pr_inProgress = value;\n        if (this.hook !== undefined) {\n            this.hook();\n        }\n    }\n}\n/**\n * @template K key type\n * @template V value type\n * @extends {Map<K,V>}\n *\n * Map automatically creating values if key is not found.\n */\nclass DefaultMap extends Map {\n    constructor(defaultFactory) {\n        super();\n        Object.defineProperty(this, \"defaultFactory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultFactory = defaultFactory;\n    }\n    get(key) {\n        if (!super.has(key)) {\n            super.set(key, this.defaultFactory(key));\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n}\n/**\n * @extends {DefaultMap<string, RunInfo>}\n *\n * DefaultMap with custom hook run when RunInfo inProgress changes value.\n */\nclass RunInfoMap extends DefaultMap {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    get(key) {\n        if (!super.has(key)) {\n            const newValue = this.defaultFactory(key);\n            newValue.hook = this.hook;\n            super.set(key, newValue);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n    setHook(hook) {\n        this.hook = hook;\n        // eslint-disable-next-line no-param-reassign\n        this.forEach((v) => { v.hook = hook; });\n    }\n}\nexport default new RunInfoMap((key) => new RunInfo(key));\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class InterfaceRegistry {\n    constructor() {\n        Object.defineProperty(this, \"exposedInterfaces\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    /**\n     * Clears the registry.\n     */\n    clearRegistry() {\n        this.exposedInterfaces.clear();\n    }\n    /**\n     * Stores graph id of a shared interface in the registry, so that when\n     * privatizing an interface we can remove it from all the graphs that use it.\n     * If the interface is not registered, an error is thrown.\n     *\n     * @param {string} intfId Id of the interface.\n     * @param {string} graphId Id of a graph that has the registered interface\n     */\n    pushGraphIdToRegistry(intfId, graphId) {\n        const sharedInterface = this.exposedInterfaces.get(intfId);\n        if (!sharedInterface) {\n            throw new Error(`Interface with id ${intfId} not found in the register.`);\n        }\n        sharedInterface.graphIds.push(graphId);\n    }\n    /**\n     * Seamlessly wraps passed `intf`, so that the properties `maxConnectionsCount`,\n     * `connectionCount` and `type` are shared between those two interfaces.\n     *\n     * @param {NodeInterface} intf Interface for which the wrapper is created.\n     */\n    createSharedInterface(intf) {\n        const sharedInterface = this.exposedInterfaces.get(intf.id);\n        if (!sharedInterface) {\n            throw new Error(`'Interface with id ${intf.id} not found in the register.`);\n        }\n        Object.defineProperty(intf, 'maxConnectionsCount', {\n            get() {\n                return sharedInterface.sharedInterface.maxConnectionsCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.maxConnectionsCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'connectionCount', {\n            get() {\n                return sharedInterface.sharedInterface.connectionCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.connectionCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'type', {\n            get() {\n                return sharedInterface.sharedInterface.type;\n            },\n        });\n    }\n    /**\n     * Checks if the interface of given id is registered.\n     *\n     * @param {string} intfId Id of the interface to check.\n     * @returns {boolean} True if the interface is registered, false otherwise.\n     */\n    isRegistered(intfId) {\n        return this.exposedInterfaces.has(intfId);\n    }\n    /**\n     * Returns the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to get.\n     */\n    getRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.get(intfId);\n    }\n    /**\n     * Deletes the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to delete\n     */\n    deleteRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.delete(intfId);\n    }\n    /**\n     * Registers an interface in the registry, so that it can be shared between\n     * multiple graph nodes. If the interface is already registered, an error is thrown.\n     *\n     * @param {NodeInterface} intf Interface to register.\n     */\n    registerInterface(intf, graphId) {\n        if (this.exposedInterfaces.has(intf.id)) {\n            throw new Error(`Trying to register an interface of id ${intf.id}, but it is already registered.`);\n        }\n        this.exposedInterfaces.set(intf.id, {\n            sharedInterface: intf,\n            sharedInterfaceGraphId: graphId,\n            graphIds: [],\n        });\n    }\n}\nexport const ir = new InterfaceRegistry();\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { useGraph } from '@baklavajs/renderer-vue';\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Function for calculating node position based on given movementStep.\n *\n * @param movementStep Vue's reference to value containing snap offset\n */\nexport function gridSnapper(movementStep) {\n    const calculateSnappedPosition = (coord) => Math.round(coord / movementStep.value) * movementStep.value;\n    return calculateSnappedPosition;\n}\n/**\n * Creates function that aligns the value of node position along specified axis if it is close\n * enough to other node position\n *\n * @param kind Either 'x' or 'y', defines along which axis the coordinate is aligned\n */\nexport function nodeSnapper(kind) {\n    const { graph } = useGraph();\n    const snapDistance = 100;\n    const calculateSnappedPosition = (coord, nodeId, selectedNodesIds) => {\n        const nearestCoords = graph.value.nodes\n            // any definition is an ad-hoc solution as we don't have our node definition\n            .filter((node) => node.id !== nodeId && !selectedNodesIds.includes(node.id))\n            .map((node) => node.position[kind])\n            .filter((otherCoords) => Math.abs(coord - otherCoords) < snapDistance);\n        return nearestCoords.length !== 0 ? Math.min(...nearestCoords) : undefined;\n    };\n    return calculateSnappedPosition;\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/*\nThe baklavajs functionality was fully copied to this file, as the original\nimplementation is not exported and cannot be integrated with custom history\nas the Commands have been replaced.\n\nThe original source is slightly adjusted to integrate with the customized history\nand the new command handler\n*/\nimport { computed, reactive, ref, } from 'vue';\nimport { v4 as uuidv4 } from 'uuid';\nimport { GRAPH_NODE_TYPE_PREFIX, } from '@baklavajs/core';\nimport { useViewModel, } from '@baklavajs/renderer-vue';\nimport { startTransaction, commitTransaction, } from './History.ts';\nimport { removeNode } from '../custom/CustomNode.js';\nexport const COPY_COMMAND = 'COPY';\nexport const DELETE_COMMAND = 'DELETE';\nexport const UNHIGHLIGHT_COMMAND = 'UNHIGHLIGHT';\nexport const PASTE_COMMAND = 'PASTE';\nexport const CLEAR_CLIPBOARD_COMMAND = 'CLEAR_CLIPBOARD';\nexport function useClipboard(displayedGraph, editor, commandHandler) {\n    const token = Symbol('ClipboardToken');\n    const nodeBuffer = ref('');\n    const connectionBuffer = ref('');\n    const consecutivePasteNumber = ref(0);\n    const isEmpty = computed(() => !nodeBuffer.value);\n    const clear = () => {\n        nodeBuffer.value = '';\n        connectionBuffer.value = '';\n    };\n    const copy = () => {\n        // find all connections from and to the selected nodes\n        const interfacesOfSelectedNodes = displayedGraph.value.selectedNodes.flatMap((n) => [\n            ...Object.values(n.inputs),\n            ...Object.values(n.outputs),\n        ]);\n        const connections = displayedGraph.value.connections\n            .filter((conn) => interfacesOfSelectedNodes.includes(conn.from) ||\n            interfacesOfSelectedNodes.includes(conn.to))\n            .map((conn) => ({ from: conn.from.id, to: conn.to.id }));\n        connectionBuffer.value = JSON.stringify(connections);\n        nodeBuffer.value = JSON.stringify(displayedGraph.value.selectedNodes.map((n) => n.save()));\n        consecutivePasteNumber.value = 0;\n    };\n    const del = () => {\n        const { viewModel } = useViewModel();\n        if (viewModel.value.editor.readonly)\n            return;\n        startTransaction();\n        displayedGraph.value.selectedNodes.forEach((node) => {\n            removeNode(node);\n        });\n        commitTransaction();\n    };\n    const findInterface = (nodes, id, io) => {\n        for (let i = 0; i < nodes.length; i += 1) {\n            let intf;\n            if (!io || io === 'input') {\n                intf = Object.values(nodes[i].inputs).find((iface) => iface.id === id);\n            }\n            if (!intf && (!io || io === 'output')) {\n                intf = Object.values(nodes[i].outputs).find((iface) => iface.id === id);\n            }\n            if (intf) {\n                return intf;\n            }\n        }\n        return undefined;\n    };\n    const paste = () => {\n        var _a, _b;\n        const { viewModel } = useViewModel();\n        if (isEmpty.value || viewModel.value.editor.readonly) {\n            return;\n        }\n        const movementStep = (_a = viewModel.value.movementStep) !== null && _a !== void 0 ? _a : 1;\n        // Map old IDs to new IDs\n        const idmap = new Map();\n        const parsedNodeBuffer = JSON.parse(nodeBuffer.value);\n        const parsedConnectionBuffer = JSON.parse(connectionBuffer.value);\n        const newNodes = [];\n        const newConnections = [];\n        const graph = displayedGraph.value;\n        commandHandler.executeCommand('START_TRANSACTION');\n        for (let i = 0; i < parsedNodeBuffer.length; i += 1) {\n            let nodeType;\n            if (((_b = parsedNodeBuffer[i]) === null || _b === void 0 ? void 0 : _b.subgraph) !== undefined) {\n                nodeType = editor.value.nodeTypes.get(`${GRAPH_NODE_TYPE_PREFIX}${parsedNodeBuffer[i].name}`);\n            }\n            else {\n                nodeType = editor.value.nodeTypes.get(parsedNodeBuffer[i].name);\n            }\n            if (!nodeType) {\n                return;\n            }\n            /* eslint-disable-next-line new-cap */\n            let copiedNode = new nodeType.type();\n            newNodes.push(copiedNode);\n            copiedNode.hooks.beforeLoad.subscribe(token, (nodeState) => {\n                const ns = nodeState;\n                if (ns.position) {\n                    consecutivePasteNumber.value += 1;\n                    ns.position.x += consecutivePasteNumber.value * Math.max(40, movementStep);\n                    ns.position.y += consecutivePasteNumber.value * Math.max(40, movementStep);\n                }\n                if (parsedNodeBuffer[i].graphState !== undefined) {\n                    parsedNodeBuffer[i].graphState.nodes.forEach((n) => {\n                        /* eslint-disable-next-line no-param-reassign */\n                        if (n.type !== undefined)\n                            n.name = n.type;\n                    });\n                }\n                copiedNode.hooks.beforeLoad.unsubscribe(token);\n                return ns;\n            });\n            copiedNode = graph.addNode(copiedNode);\n            const mapNewId = (obj) => {\n                /* eslint-disable no-param-reassign */\n                const newId = uuidv4();\n                idmap.set(obj.id, newId);\n                obj.id = newId;\n            };\n            const assignNewIds = (node) => {\n                /* eslint-disable no-param-reassign */\n                // New node id\n                mapNewId(node);\n                if (node.graphState !== undefined) {\n                    mapNewId(node.graphState);\n                    node.graphState.nodes.forEach((subNode) => {\n                        assignNewIds(subNode);\n                    });\n                    // If it is a subgraph node, then some interfaces have to have the same IDs\n                    // as the ones in the subgraph\n                    node.interfaces.forEach((intf) => {\n                        var _a;\n                        intf.id = (_a = idmap.get(intf.id)) !== null && _a !== void 0 ? _a : intf.id;\n                        // If the node has any external interfaces, then their names have\n                        // to be resolved as they cannot conflict with the existing ones.\n                        if (intf.externalName !== undefined) {\n                            intf.externalName = graph.resolveNewExposedName(intf.externalName);\n                        }\n                    });\n                    node.graphState.connections.forEach((conn) => {\n                        if (idmap.get(conn.from) === undefined ||\n                            idmap.get(conn.to) === undefined) {\n                            throw new Error('Error when executing copy and paste. ' +\n                                `Connection from interface ${conn.from} to ${conn.to} is invalid`);\n                        }\n                        conn.from = idmap.get(conn.from);\n                        conn.to = idmap.get(conn.to);\n                    });\n                }\n                else {\n                    // If it is a regular node, then interfaces need new IDs.\n                    node.interfaces.forEach((intf) => {\n                        mapNewId(intf);\n                        // If the node has any external interfaces, then their names have\n                        // to be resolved as they cannot conflict with the existing ones.\n                        if (intf.externalName !== undefined) {\n                            intf.externalName = graph.resolveNewExposedName(intf.externalName);\n                        }\n                    });\n                }\n            };\n            assignNewIds(parsedNodeBuffer[i]);\n            copiedNode.load(Object.assign(Object.assign({}, parsedNodeBuffer[i]), { id: copiedNode.id }));\n            // If the pasted graph was inside of a graph node, then the graph node has to\n            // have its exposed interfaces refreshed\n            if (displayedGraph.value.graphNode !== undefined) {\n                displayedGraph.value.graphNode.updateExposedInterfaces();\n            }\n        }\n        for (let i = 0; i < parsedConnectionBuffer.length; i += 1) {\n            const fromId = idmap.get(parsedConnectionBuffer[i].from);\n            const toId = idmap.get(parsedConnectionBuffer[i].to);\n            if (fromId && toId) {\n                const fromIntf = findInterface(newNodes, fromId, 'output');\n                const toIntf = findInterface(newNodes, toId, 'input');\n                if (fromIntf && toIntf) {\n                    const newConnection = graph.addConnection(fromIntf, toIntf);\n                    if (newConnection) {\n                        newConnections.push(newConnection);\n                    }\n                }\n            }\n        }\n        commandHandler.executeCommand('COMMIT_TRANSACTION');\n        /* eslint-disable-next-line consistent-return */\n        return {\n            newNodes,\n            newConnections,\n        };\n    };\n    commandHandler.registerCommand(DELETE_COMMAND, {\n        canExecute: () => displayedGraph.value.selectedNodes.length > 0,\n        execute: del,\n    });\n    commandHandler.registerHotkey(['Delete'], DELETE_COMMAND);\n    commandHandler.registerCommand(UNHIGHLIGHT_COMMAND, {\n        canExecute: () => true,\n        execute: () => {\n            displayedGraph.value.selectedNodes = []; // eslint-disable-line no-param-reassign\n        },\n    });\n    commandHandler.registerHotkey(['Escape'], UNHIGHLIGHT_COMMAND);\n    commandHandler.registerCommand(COPY_COMMAND, {\n        canExecute: () => true,\n        execute: copy,\n    });\n    commandHandler.registerHotkey(['Control', 'c'], COPY_COMMAND);\n    commandHandler.registerCommand(PASTE_COMMAND, {\n        canExecute: () => !isEmpty.value,\n        execute: paste,\n    });\n    commandHandler.registerHotkey(['Control', 'v'], PASTE_COMMAND);\n    commandHandler.registerCommand(CLEAR_CLIPBOARD_COMMAND, {\n        canExecute: () => true,\n        execute: clear,\n    });\n    return reactive({ isEmpty });\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n */\n\n/* eslint-disable class-methods-use-this */\nexport default class BaklavaInterfaceTypes {\n    types = new Map();\n\n    defaultStyle = {\n        interfaceConnectionPattern: 'solid',\n        interfaceConnectionColor: '#FFFFFF', // $white\n        interfaceColor: '#00E58D', // $green\n    };\n\n    /**\n     * Initialize Interface types instance used to manager styles of interfaces and connections\n     * and validate adding connections.\n     */\n    constructor(viewPlugin) {\n        viewPlugin.hooks.renderInterface.subscribe(this, ({ intf, el }) => {\n            if (intf.type) {\n                const types = this.normalizeType(intf.type);\n                const firstType = types.find((t) => this.types[t]?.interfaceColor !== undefined);\n\n                if (firstType !== undefined) {\n                    const color = this.types[firstType].interfaceColor;\n                    const arrow = el.querySelector('.__port:not(.greyedout_arrow)'); // eslint-disable-line no-param-reassign\n                    if (arrow !== null) arrow.style.backgroundColor = color;\n                    else {\n                        const greyArrow = el.querySelector('.__port');\n                        if (greyArrow !== null) {\n                            greyArrow.style.backgroundColor =\n                                getComputedStyle(greyArrow).getPropertyValue('$gray-500');\n                        }\n                    }\n                }\n            }\n\n            return { intf, el };\n        });\n    }\n\n    normalizeType(type) {\n        return typeof type === 'string' || type instanceof String ? [type] : type;\n    }\n\n    /**\n     * Returns connection style for a given from and to interfaces.\n     * It takes style of a common type of those interfaces and completes its missing values\n     * with default ones. If there are multiple common types, a default style is returned.\n     *\n     * If there is no `to` interface then a style for `from` interface is returned.\n     * Again with completed missing values.\n     *\n     * @param {Interface} from connection source\n     * @param {Interface} to connection target\n     * @returns style for a defined connection\n     */\n    getConnectionStyle(from, to) {\n        const fromTypes = this.normalizeType(from?.type);\n        const toTypes = this.normalizeType(to?.type);\n\n        if (from?.type === undefined) {\n            return this.defaultStyle;\n        }\n\n        if (to?.type === undefined) {\n            const firstType = fromTypes.find((t) => this.types[t] !== undefined);\n            return { ...this.defaultStyle, ...this.types[firstType] };\n        }\n\n        const commonTypes = fromTypes.filter((t) => toTypes.includes(t));\n        if (Array.isArray(commonTypes) && commonTypes.length > 1) {\n            return this.defaultStyle;\n        }\n\n        const firstType = commonTypes.find((t) => this.types[t] !== undefined);\n        return { ...this.defaultStyle, ...this.types[firstType] };\n    }\n\n    /**\n     * Function that reads all nodes in the specification and creates `NodeInterfaceType` objects\n     * for their inputs' and outputs' types so that a simple validation based on those\n     * types can be performed.\n     *\n     * The read interface types are stored in `interfaceTypes` object which is returned by\n     * this function\n     * @param {*} metadata metadata containing information about styling\n     * @returns read interface types\n     */\n    readInterfaceTypes(metadata) {\n        this.types = {};\n        if (metadata?.interfaces) {\n            Object.entries(metadata.interfaces).forEach(([type, io]) => {\n                this.types[type] = { ...io, name: type };\n            });\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Handles calculation of a SVG path a connection should have based on it's characteristic\n * (for example loopback) and style. It is handled by `ConnectionRenderer`, which\n * deals with saving the style user has chosen and delegating away the calculation to\n * suitable renderer\n */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Used for loopback connections, calculates the y coordinate of a bottom point of a node\n * based on it's DOM element. If the element does not yet exists, returns 0\n *\n * @param connection BaklavaJS-defined connection\n * @param scaling number from viewModel defining the scaling of canvas\n * @param panning (x, y) point from viewModel defining the translation of canvas\n * @returns Y coordinate of a bottom of a node, adjusted for canvas transformation\n */\nfunction nodeBottomPoint(connection, scaling, panning) {\n    const { nodeId } = connection.from;\n    const nodeHtml = document.getElementById(nodeId);\n    const nodeBottom = nodeHtml ? nodeHtml.offsetTop + nodeHtml.offsetHeight : 0;\n    return (nodeBottom + panning.y) * scaling;\n}\n\n/**\n * Utility function that calculates the x and y radius of an ellipse given center point and\n * a slope at a specified point\n *\n * @param x X coordinate of a point on an ellipse\n * @param y Y coordinate of a point on an ellipse\n * @param cx X coordinate of a center point\n * @param cy Y coordinate of a center point\n * @param slope dy/dx value on a (x, y) point\n * @returns Array of two elements: radius parallel to x axis and y axis respectively\n */\nfunction calculateEllipseR(x, y, cx, cy, slope) {\n    const rx = Math.sqrt(Math.abs((x - cx) * (x - cx) + ((x - cx) * (y - cy)) / slope));\n    const ry = Math.sqrt(Math.abs((y - cy) * (y - cy) + (y - cy) * (x - cx) * slope));\n    return [rx, ry];\n}\n\nclass NormalizedConnection {\n    /**\n     * Class that makes sure that the connection is in correct order, which means that from and to\n     * sockets and their coordinates are properly set.\n     */\n    constructor(x1, y1, x2, y2, connection) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.from = connection.from;\n        if (connection.to) {\n            this.to = connection.to;\n            if (\n                (this.from.direction === 'input' && this.to.direction === 'output') ||\n                (this.from.direction === 'input' && this.to.direction === 'inout') ||\n                (this.from.direction === 'inout' && this.to.direction === 'output')\n            ) {\n                [this.x1, this.x2, this.y1, this.y2] = [this.x2, this.x1, this.y2, this.y1];\n                [this.from, this.to] = [this.to, this.from];\n            }\n        }\n    }\n}\n\nexport default class ConnectionRenderer {\n    style = 'curved';\n\n    viewModel = null;\n\n    randomizedOffset = false;\n\n    /**\n     * Defines the shift the connection should have compared to the default position based on the\n     * index of the `from` interface and `to` interface bound to the connection in the nodes.\n     * It allows to make a visual distinction between connections going to different interfaces\n     * in the same node. The value of the shift is constant distance times the index of an\n     * interface, adjusted for any canvas transformation\n     * This funnction is symmetrical.\n     *\n     * @param ncFrom from node reference\n     * @param ncTo to node reference\n     * @param graph the graph definition\n     * @param scaling number from viewModel defining the scaling of canvas\n     * @returns Value the connection should shift from it's default position\n     */\n    getShift(ncFrom, ncTo, graph, scaling) {\n        const shiftDistance = 15;\n        const fromNode = graph.findNodeById(ncFrom.nodeId);\n        const toNode = graph.findNodeById(ncTo.nodeId);\n\n        const fromPosition = ncFrom.sidePosition;\n        const toPosition = ncTo.sidePosition;\n\n        const shiftIndex = (fromPosition + toPosition) / 2;\n\n        if (this.randomizedOffset) {\n            const fromNodeNeighbours = [\n                ...Object.values(fromNode.inputs),\n                ...Object.values(fromNode.outputs),\n            ].filter((c) => c.side === ncFrom.side && c.port);\n            const toNodeNeighbours = [\n                ...Object.values(toNode.inputs),\n                ...Object.values(toNode.outputs),\n            ].filter((c) => c.side === ncTo.side && c.port);\n\n            // the string is a sum of utf16 representation of each character\n            const toRandomIndex =\n                [...ncTo.id].reduce((accumulator, char) => accumulator + char.charCodeAt(0), 0) ??\n                0;\n            const fromRandomIndex =\n                [...ncFrom.id].reduce((accumulator, char) => accumulator + char.charCodeAt(0), 0) ??\n                0;\n\n            const randomIndex =\n                (toRandomIndex ^ fromRandomIndex) % // eslint-disable-line no-bitwise\n                (fromNodeNeighbours.length + toNodeNeighbours.length);\n            return shiftDistance * (randomIndex + shiftIndex) * scaling;\n        }\n\n        return shiftDistance * shiftIndex * scaling;\n    }\n\n    /* eslint-disable class-methods-use-this */\n    curvedRender(x1, y1, x2, y2, connection) {\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const dx = 0.3 * Math.abs(nc.x1 - nc.x2);\n\n        if (nc.to) {\n            if (nc.from.side === 'right' && nc.to.side === 'left') {\n                return `M ${nc.x1} ${nc.y1} C ${nc.x1 + dx} ${nc.y1}, ${nc.x2 - dx} ${nc.y2}, ${\n                    nc.x2\n                } ${nc.y2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'right') {\n                return `M ${nc.x1} ${nc.y1} C ${nc.x1 - dx} ${nc.y1}, ${nc.x2 + dx} ${nc.y2}, ${\n                    nc.x2\n                } ${nc.y2}`;\n            }\n            if (nc.from.side === 'right' && nc.to.side === 'right') {\n                const rightmost = Math.max(nc.x1 + dx, nc.x2 + dx);\n                return `M ${nc.x1} ${nc.y1} C ${rightmost} ${nc.y1}, ${rightmost} ${nc.y2}, ${nc.x2} ${nc.y2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'left') {\n                const leftmost = Math.min(nc.x1 - dx, nc.x2 - dx);\n                return `M ${nc.x1} ${nc.y1} C ${leftmost} ${nc.y1}, ${leftmost} ${nc.y2}, ${nc.x2} ${nc.y2}`;\n            }\n        }\n\n        if (nc.from.side === 'right') {\n            return `M ${nc.x1} ${nc.y1} C ${nc.x1 + dx} ${nc.y1}, ${nc.x2 - dx} ${nc.y2}, ${\n                nc.x2\n            } ${nc.y2}`;\n        }\n        if (nc.from.side === 'left') {\n            return `M ${nc.x1} ${nc.y1} C ${nc.x1 - dx} ${nc.y1}, ${nc.x2 + dx} ${nc.y2}, ${\n                nc.x2\n            } ${nc.y2}`;\n        }\n\n        // unreachable, added to make eslint happy\n        return undefined;\n    }\n\n    curvedRenderLoopback(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const sideMargin = 10 * graph.scaling;\n\n        if (nc.from.id === nc.to.id) {\n            // The same interface\n            const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n            const x = nc.from.side === 'right' ? nc.x1 + shift : nc.x1 - shift;\n            return `M ${nc.x1} ${nc.y1}\n            A ${sideMargin} ${sideMargin / 2} 0 0 0 ${x} ${nc.y1}\n            A ${sideMargin} ${sideMargin / 2} 0 0 0 ${nc.x1} ${nc.y1}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'left') {\n            const leftRx = sideMargin;\n            const leftRy = Math.abs(nc.y1 - nc.y2) / 2;\n            const renderingSide = nc.y1 > nc.y2 ? 1 : 0;\n\n            return `M ${nc.x1} ${nc.y1}\n            A ${leftRx} ${leftRy} 0 0 ${renderingSide} ${nc.x2} ${nc.y2}`;\n        }\n        if (nc.from.side === 'right' && nc.to.side === 'right') {\n            const leftRx = sideMargin;\n            const leftRy = Math.abs(nc.y1 - nc.y2) / 2;\n            const renderingSide = nc.y1 > nc.y2 ? 0 : 1;\n\n            return `M ${nc.x1} ${nc.y1}\n            A ${leftRx} ${leftRy} 0 0 ${renderingSide} ${nc.x2} ${nc.y2}`;\n        }\n\n        const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n\n        const leftx = nc.from.side === 'left' ? nc.x1 : nc.x2;\n        const rightx = nc.to.side === 'right' ? nc.x2 : nc.x1;\n\n        const lefty = nc.from.side === 'left' ? nc.y1 : nc.y2;\n        const righty = nc.to.side === 'right' ? nc.y2 : nc.y1;\n        const bottomY = nodeBottomPoint(connection, graph.scaling, graph.panning);\n\n        const y = bottomY + shift;\n\n        const rightCx = rightx - shift;\n        const rightCy = (y + righty) / 2;\n        const [rightRx, rightRy] = calculateEllipseR(rightx, y, rightCx, rightCy, 1);\n\n        const bottomCx = (rightx + leftx) / 2;\n        const bottomCy = bottomY;\n        const [bottomRx, bottomRy] = calculateEllipseR(rightx, y, bottomCx, bottomCy, 1);\n\n        const leftCx = leftx + shift;\n        const leftCy = (y + lefty) / 2;\n        const [leftRx, leftRy] = calculateEllipseR(leftx, y, leftCx, leftCy, -1);\n\n        return `M ${rightx} ${righty}\n        A ${rightRx} ${rightRy} 0 0 1 ${rightx} ${y}\n        A ${bottomRx} ${bottomRy} 0 0 1 ${leftx} ${y}\n        A ${leftRx} ${leftRy} 0 0 1 ${leftx} ${lefty}`;\n    }\n\n    orthogonalRender(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n\n        if (connection.anchors !== undefined && connection.anchors.length) {\n            const anchors = connection.anchors.map((anchor) => {\n                const transform = (a) => {\n                    const tx = (a.x + graph.panning.x) * graph.scaling;\n                    const ty = (a.y + graph.panning.y) * graph.scaling;\n                    return { x: tx, y: ty };\n                };\n\n                return transform(anchor);\n            });\n\n            const path = [{ x: nc.x1, y: nc.y1 }];\n            let direction = nc.from.side;\n            if (direction === 'right') {\n                path.push({ x: nc.x1 + 10, y: nc.y1 });\n            } else if (direction === 'left') {\n                path.push({ x: nc.x1 - 10, y: nc.y1 });\n            }\n            direction = 'horizontal';\n            anchors.forEach((anchor) => {\n                if (direction === 'vertical') {\n                    path.push({\n                        x: path[path.length - 1].x + (anchor.x - path[path.length - 1].x) / 2,\n                        y: path[path.length - 1].y,\n                    });\n                    path.push({\n                        x: path[path.length - 2].x + (anchor.x - path[path.length - 2].x) / 2,\n                        y: anchor.y,\n                    });\n                    path.push({\n                        x: anchor.x,\n                        y: anchor.y,\n                    });\n                    direction = 'horizontal';\n                } else {\n                    path.push({\n                        x: path[path.length - 1].x,\n                        y: path[path.length - 1].y + (anchor.y - path[path.length - 1].y) / 2,\n                    });\n                    path.push({\n                        x: anchor.x,\n                        y: path[path.length - 2].y + (anchor.y - path[path.length - 2].y) / 2,\n                    });\n                    path.push({\n                        x: anchor.x,\n                        y: anchor.y,\n                    });\n                    direction = 'vertical';\n                }\n            });\n            if (direction === 'vertical') {\n                path.push({\n                    x: path[path.length - 1].x + (nc.x2 - path[path.length - 1].x) / 2,\n                    y: path[path.length - 1].y,\n                });\n                path.push({\n                    x: path[path.length - 2].x + (nc.x2 - path[path.length - 2].x) / 2,\n                    y: nc.y2,\n                });\n                path.push({\n                    x: nc.x2,\n                    y: nc.y2,\n                });\n            } else {\n                path.push({\n                    x: path[path.length - 1].x,\n                    y: path[path.length - 1].y + (nc.y2 - path[path.length - 1].y) / 2,\n                });\n                let offset = 0;\n                if (nc.to.side === 'left') offset = 10;\n                else offset = -10;\n                path.push({\n                    x: nc.x2 - offset,\n                    y: path[path.length - 2].y + (nc.y2 - path[path.length - 2].y) / 2,\n                });\n                path.push({\n                    x: nc.x2 - offset,\n                    y: nc.y2,\n                });\n                path.push({\n                    x: nc.x2,\n                    y: nc.y2,\n                });\n            }\n            return path;\n        }\n\n        const minMargin = 30 * graph.scaling;\n        const middlePoint = (nc.x1 + nc.x2) / 2;\n\n        if (connection.to) {\n            const shift = this.getShift(nc.from, nc.to, graph, graph.scaling);\n\n            if (nc.from.side === 'right' && nc.to.side === 'left') {\n                const mid = Math.max(nc.x1, middlePoint) + shift + minMargin;\n\n                const firstTurn = mid < nc.x2 - shift - minMargin ? nc.x1 + shift + minMargin : mid;\n                const lastTurn = nc.x2 - shift - minMargin;\n\n                // S connection\n                if (\n                    mid >= nc.x2 - shift - minMargin &&\n                    (firstTurn > nc.x2 - minMargin || lastTurn < nc.x1 - minMargin)\n                ) {\n                    return `M ${nc.x1} ${nc.y1}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y2}\n                    H ${nc.x2}`;\n                }\n\n                // Z connection\n                return `M ${nc.x1} ${nc.y1} H ${mid} V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'right') {\n                const mid = Math.max(nc.x2, middlePoint) + shift + minMargin;\n\n                const firstTurn = mid < nc.x1 - shift - minMargin ? nc.x2 + shift + minMargin : mid;\n                const lastTurn = nc.x1 - shift - minMargin;\n\n                // S connection\n                if (\n                    mid >= nc.x1 - shift - minMargin &&\n                    (firstTurn > nc.x1 - minMargin || lastTurn < nc.x2 - minMargin)\n                ) {\n                    return `M ${nc.x2} ${nc.y2}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y1}\n                    H ${nc.x1}`;\n                }\n\n                // Z connection\n                return `M ${nc.x2} ${nc.y2} H ${mid} V ${nc.y1} H ${nc.x1}`;\n            }\n            if (nc.from.side === 'right' && nc.to.side === 'right') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.max(nc.x1, nc.x2, middlePoint) + shift + minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'left') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.min(nc.x1, nc.x2, middlePoint) - shift - minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n        }\n        return `M ${nc.x1} ${nc.y1} H ${middlePoint} V ${nc.y2} H ${nc.x2}`;\n    }\n\n    orthogonalRenderLoopback(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n\n        if (connection.anchors !== undefined && connection.anchors.length) {\n            const anchors = connection.anchors.map((a) => {\n                const tx = (a.x + graph.panning.x) * graph.scaling;\n                const ty = (a.y + graph.panning.y) * graph.scaling;\n                return { x: tx, y: ty };\n            });\n\n            const path = [{ x: nc.x1, y: nc.y1 }];\n            const direction = nc.from.side;\n            const xShift = direction === 'right' ? shift : -shift;\n            path.push({ x: nc.x1 + xShift, y: nc.y1 });\n            anchors.forEach((anchor) => {\n                path.push({\n                    x: path[path.length - 1].x,\n                    y: anchor.y,\n                });\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n                // NOTE: Duplicate path is for proper anchor position calculation\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n            });\n            path.push({\n                x: path[path.length - 1].x,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2 + xShift,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2,\n                y: nc.y2,\n            });\n            return path;\n        }\n\n        const bottomY = nodeBottomPoint(connection, graph.scaling, graph.panning);\n        const y = bottomY + shift;\n\n        if (nc.from.side === 'right' && nc.to.side === 'left') {\n            return `M ${nc.x1} ${nc.y1}\n            h ${shift}\n            V ${y} H ${nc.x2 - shift} V ${nc.y2} H ${nc.x2}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'right') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${shift}\n            V ${y} H ${nc.x1 - shift} V ${nc.y1} H ${nc.x1}`;\n        }\n        if (nc.from.side === 'right' && nc.to.side === 'right') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${shift}\n            V ${nc.y1} H ${nc.x1}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'left') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${-shift}\n            V ${nc.y1} H ${nc.x1}`;\n        }\n        // unreachable, added to make eslint happy\n        return undefined;\n    }\n\n    constructor(viewModel, style, randomizedOffset = false) {\n        this.viewModel = viewModel;\n        this.style = style;\n        this.randomizedOffset = randomizedOffset;\n    }\n\n    /**\n     * Chooses the render method based on active style and connection characteristic\n     *\n     * @param x1 X coordinate of from interface\n     * @param y1 Y coordinate of from interface\n     * @param x2 X coordinate of to interface\n     * @param y2 Y coordinate of to interface\n     * @param connection BaklavaJS-defined connection to render\n     * @returns String defining connection path in SVG format\n     */\n    render(x1, y1, x2, y2, connection) {\n        const loopback = this.isLoopback(connection) ? 'Loopback' : '';\n        return this[`${this.style}Render${loopback}`](x1, y1, x2, y2, connection);\n    }\n\n    /**\n     * Tests whether the connection is loopback (connects the node with itself)\n     *\n     * @param connection BaklavaJS-defined connection to test\n     * @returns True if connection is loopback.\n     */\n    isLoopback(connection) {\n        // Temporary connections that are not connected to any output (.to is undefined)\n        // are not loopback\n        return !!connection.to && connection.from.nodeId === connection.to.nodeId;\n    }\n}\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Class used to store the current specification and unresolved specification\n * of the current session.\n *\n * This class should be used as a singleton and should be accessed using the\n * getInstance() function.\n */\nimport { GRAPH_NODE_TYPE_PREFIX } from '@baklavajs/core';\n\nexport default class Specification {\n    static instance = undefined;\n\n    currentSpecification = undefined;\n\n    unresolvedSpecification = undefined;\n\n    constructor() {\n        if (Specification.instance !== undefined) {\n            throw new Error('Error - use Specification.getInstance()');\n        }\n    }\n\n    /**\n     * Static function used to get the instance of the Specification in a singleton manner.\n     * If there is no existing instance of the Specification then a new one is created.\n     *\n     * @returns Instance of Specification.\n     */\n    static getInstance() {\n        if (!Specification.instance) {\n            Specification.instance = new Specification();\n        }\n        return Specification.instance;\n    }\n\n    /**\n     * Searches the current specification for a node with the given name.\n     *\n     * @param nodeName name of the node that is to be found in the specification\n     * @returns the specification of the node if it exists, otherwise undefined\n     */\n    getNodeSpecification(nodeName) {\n        if (this.currentSpecification === undefined) return undefined;\n\n        if (nodeName.startsWith(GRAPH_NODE_TYPE_PREFIX)) {\n            return this.currentSpecification.graphs.find(\n                (n) => n.name === nodeName.slice(GRAPH_NODE_TYPE_PREFIX.length),\n            );\n        }\n\n        return this.currentSpecification.nodes.find(\n            (n) => n.name === nodeName,\n        );\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\nimport { stringify } from 'ajv';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport jsonMap from 'json-source-map';\nimport jsonlint from 'jsonlint';\n\nimport { useBaklava, useCommandHandler } from '@baklavajs/renderer-vue';\nimport { GRAPH_NODE_TYPE_PREFIX } from '@baklavajs/core';\nimport { toRaw, ref } from 'vue';\nimport { useHistory } from './History.ts';\nimport { useClipboard } from './Clipboard.ts';\n\nimport PipelineManagerEditor from '../custom/Editor.js';\nimport InterfaceTypes from './InterfaceTypes.js';\n\nimport { NodeFactory, GraphFactory } from './NodeFactory.js';\nimport unresolvedSpecificationSchema from '../../../resources/schemas/unresolved_specification_schema.json' assert { type: 'json' };\nimport specificationSchema from '../../../resources/schemas/specification_schema.json' assert { type: 'json' };\nimport metadataSchema from '../../../resources/schemas/metadata_schema.json' assert { type: 'json' };\nimport dataflowSchema from '../../../resources/schemas/dataflow_schema.json' assert { type: 'json' };\nimport graphSchema from '../../../resources/schemas/graph_schema.json' assert { type: 'json' };\nimport ConnectionRenderer from './ConnectionRenderer.js';\nimport Specification from './Specification.js';\n\n/* eslint-disable lines-between-class-members */\n/**\n * Readonly helper class that reads and stores default values from metadata schema.\n */\nclass Metadata {\n    constructor() {\n        Object.entries(metadataSchema.properties).forEach(([name, state]) => {\n            this[name] = state.default;\n        });\n    }\n}\n\n// If a graph node entry does not have a category assigned, this values is used\n// as a fallback category\nexport const DEFAULT_GRAPH_NODE_CATEGORY = 'Graphs';\nexport const DEFAULT_GRAPH_NODE_NAME = 'New Graph Node';\nexport const DEFAULT_GRAPH_NODE_TYPE = `${GRAPH_NODE_TYPE_PREFIX}${DEFAULT_GRAPH_NODE_NAME}`;\n\n/**\n * Translates the provided url according to\n * the optional substitution spec provided at compile time.\n *\n * @param loc the encoded URL location of the resource\n * @returns a translated URL\n */\nfunction parseLocation(loc) {\n    let relativeurl = '{}';\n    if (typeof document !== 'undefined') {\n        const urlparent = document.location.href.split('/').slice(0, -1).join('/');\n        relativeurl = `${urlparent}/{}`;\n    }\n    const defaultsubs = `{\"https\": \"https://{}\", \"http\": \"http://{}\", \"relative\": \"${relativeurl}\"}`;\n    const jsonsubs = process.env.VUE_APP_JSON_URL_SUBSTITUTES ?? defaultsubs;\n    const subs = JSON.parse(jsonsubs);\n    const parts = loc.split('//');\n\n    if (parts.length < 2) return undefined;\n\n    const key = parts[0].substring(0, parts[0].length - 1);\n    const specifiedUrl = parts.slice(1).join('');\n\n    if (!Object.keys(subs).includes(key)) return undefined;\n    return subs[key].replace('{}', specifiedUrl);\n}\n\n/**\n * Loads the JSON file from the remote location given in URL.\n *\n * @param customLocation the URL location of the resource\n * @returns a tuple of a boolean and a JSON object or an error message.\n * The boolean is true if the JSON was successfully loaded and parsed\n */\nexport async function loadJsonFromRemoteLocation(customLocation) {\n    const location = parseLocation(customLocation);\n    if (location === undefined) {\n        return [false, `Could not download the resource from:  ${customLocation}.`];\n    }\n    let fetchedContent;\n    try {\n        fetchedContent = await fetch(location, { mode: 'cors' });\n    } catch (error) {\n        return [false, error.message];\n    }\n    try {\n        const jsonContent = await fetchedContent.json();\n        return [true, jsonContent];\n    } catch (error) {\n        return [false, error.message];\n    }\n}\n\nexport default class EditorManager {\n    static instance;\n\n    defaultMetadata = new Metadata();\n\n    editor = new PipelineManagerEditor();\n\n    baklavaView = useBaklava(this.editor);\n\n    specificationLoaded = ref(false);\n\n    specification = Specification.getInstance();\n\n    updatedMetadata = {};\n\n    constructor() {\n        // Baklava's view registers subgraph input and output nodes\n        // This call un-registers them as obsolete\n        this.editor.unregisterNodes();\n\n        this.baklavaView.connectionRenderer = new ConnectionRenderer(\n            this.baklavaView,\n            this.defaultMetadata.connectionStyle,\n            this.defaultMetadata.randomizedOffset,\n        );\n\n        this.baklavaView.editor.layoutManager.useAlgorithm(this.defaultMetadata.layout);\n        this.baklavaView.interfaceTypes = new InterfaceTypes(this.baklavaView);\n\n        // need to be set here as settings try to use this value\n        // before this value can be loaded from specification\n        this.baklavaView.layers = this.defaultMetadata.layers;\n        this.baklavaView.collapseSidebar = this.defaultMetadata.collapseSidebar;\n        this.baklavaView.movementStep = this.defaultMetadata.movementStep;\n        this.baklavaView.editor.allowLoopbacks = this.defaultMetadata.allowLoopbacks;\n        this.baklavaView.navbarItems = this.defaultMetadata.navbarItems;\n        this.baklavaView.cache = {};\n        this.baklavaView.logLevel = this.defaultMetadata.logLevel;\n\n        this.specificationVersion = unresolvedSpecificationSchema.version;\n        this.baklavaView.commandHandler = useCommandHandler();\n        this.baklavaView.history = null;\n        this.baklavaView.history = useHistory(\n            toRaw(this.baklavaView).displayedGraph,\n            this.baklavaView.commandHandler,\n        );\n        this.baklavaView.clipboard = useClipboard(\n            toRaw(this.baklavaView).displayedGraph,\n            ref(this.baklavaView.editor),\n            this.baklavaView.commandHandler,\n        );\n    }\n\n    /**\n     * Loads the dataflow specification passed in `dataflowSpecification`.\n     * The specification describes what nodes are available in the editor.\n     *\n     * If the current editor already has a specification loaded then the editor\n     * and its plugins are reinitialized and then the specification is loaded.\n     *\n     * @param dataflowSpecification Specification to load, can be either an object or a string\n     * @param lazyLoad Decides whether to actually load the specification or just store\n     * it and check its versioning. Can be used when loading parts of specification manually.\n     * @returns An object consisting of errors and warnings arrays. If any array is empty\n     * the updating process was successful.\n     */\n    /* eslint-disable no-underscore-dangle,no-param-reassign */\n    async updateEditorSpecification(dataflowSpecification, lazyLoad = false) {\n        if (!dataflowSpecification) return ['No specification passed'];\n\n        if (typeof dataflowSpecification === 'string' || dataflowSpecification instanceof String) {\n            try {\n                dataflowSpecification = jsonlint.parse(dataflowSpecification);\n            } catch (error) {\n                return { errors: [error], warnings: [] };\n            }\n        }\n\n        if (this.specificationLoaded) {\n            this.clearEditorManagerState();\n        }\n\n        const warnings = [];\n        const errors = [];\n        const { version } = dataflowSpecification; // eslint-disable-line object-curly-newline,max-len\n        if (!this.specification.currentSpecification) {\n            if (version === undefined) {\n                warnings.push(\n                    `Loaded specification has no version assigned. Please update the specification to version ${this.specificationVersion}.`,\n                );\n            } else if (version !== this.specificationVersion) {\n                warnings.push(\n                    `The specification format version (${version}) differs from the current specification format version (${this.specificationVersion}). It may result in an unexpected behaviour.`,\n                );\n            }\n        }\n\n        this.specification.unresolvedSpecification = JSON.parse(JSON.stringify(\n            dataflowSpecification,\n        ));\n        this.specification.currentSpecification = dataflowSpecification;\n        if (!lazyLoad) {\n            // Preprocess includes\n            this.globalVisitedSpecs = new Set();\n            const {\n                specification: unresolvedSpecification, errors: includeErrors,\n            } = await this.downloadNestedImports(dataflowSpecification);\n            errors.push(...includeErrors);\n            if (errors.length) {\n                return { errors, warnings };\n            }\n\n            // Include graphs\n            if (unresolvedSpecification.includeGraphs !== undefined) {\n                const {\n                    graphs, errors: includeGraphsErrors,\n                } = await EditorManager.includeGraphs(unresolvedSpecification.includeGraphs);\n\n                errors.push(...includeGraphsErrors);\n                if (errors.length) {\n                    return { errors, warnings };\n                }\n\n                unresolvedSpecification.graphs = [\n                    ...(unresolvedSpecification.graphs ?? []),\n                    ...graphs,\n                ];\n            } else {\n                unresolvedSpecification.graphs ??= [];\n            }\n\n            // Update metadata\n            const { metadata } = unresolvedSpecification;\n            errors.push(...this.updateMetadata(metadata, false, true));\n            if (errors.length) {\n                return { errors, warnings };\n            }\n\n            // Update graph specification\n            const {\n                errors: newErrors, warnings: newWarnings,\n            } = await this.updateGraphSpecification(unresolvedSpecification);\n            errors.push(...newErrors);\n            warnings.push(...newWarnings);\n        }\n\n        if (errors.length === 0) {\n            this.specificationLoaded = true;\n        } else {\n            this.clearEditorManagerState();\n        }\n\n        return { errors, warnings };\n    }\n\n    clearEditorManagerState() {\n        this.baklavaView.editor.unregisterGraphs();\n        this.baklavaView.editor.deepCleanEditor();\n        this.baklavaView.editor.unregisterNodes();\n        this.specificationLoaded = false;\n        this.specification.currentSpecification = {};\n        this.specification.unresolvedSpecification = {};\n    }\n\n    /**\n     * Downloads nested imports from the specification and returns an object\n     * consisting of nodes, graphs, and errors arrays.\n     *\n     * @param specification Specification to load.\n     * @param trace Set of visited specifications to detect circular imports.\n     * @returns Merged specification and errors.\n     */\n    async downloadNestedImports(specification, trace = new Set()) {\n        const errors = [];\n\n        // Download specifications and verify for circular imports\n        const specificationAndTrace = [];\n        const currentImports = new Set();\n        const include = specification.include ?? [];\n        await Promise.all(include.map(async (specificationUrl) => {\n            if (currentImports.has(specificationUrl)) {\n                errors.push(`Specification is included multiple times, skipping ${specificationUrl}`);\n                return;\n            }\n            if (trace.has(specificationUrl)) {\n                errors.push(`Circular dependency detected in included specification ${specificationUrl}`);\n                return;\n            }\n            currentImports.add(specificationUrl);\n\n            if (!this.globalVisitedSpecs.has(specificationUrl)) {\n                this.globalVisitedSpecs.add(specificationUrl);\n                const [status, val] = await loadJsonFromRemoteLocation(specificationUrl);\n                if (status === false) {\n                    errors.push(`Could not load the included specification from ${specificationUrl}. Reason: ${val}`);\n                } else {\n                    specificationAndTrace.push(\n                        {\n                            specification: val,\n                            trace: new Set([...trace, specificationUrl]), // Detect circular imports\n                        },\n                    );\n                }\n            }\n        }));\n\n        if (errors.length) {\n            return { specification, errors };\n        }\n\n        // Download nested imports\n        await Promise.all(specificationAndTrace.map(\n            async ({ specification: spec, trace: specTrace },\n            ) => {\n                const {\n                    specification: newSpecification, errors: newErrors,\n                } = await this.downloadNestedImports(spec, specTrace);\n                errors.push(...newErrors);\n                specification = EditorManager.mergeObjects(specification, newSpecification);\n            }));\n        return { specification, errors };\n    }\n\n    /**\n     * Downloads included dataflows from the specification and converts them to the\n     * graphs format to be included into the specification.\n     *\n     * @param includeGraphs Array of included graphs\n     * @returns Array graphs and an array of errors that occurred during the process.\n     */\n    static async includeGraphs(includeGraphs) {\n        const errors = [];\n        const graphs = [];\n\n        if (includeGraphs.length === 0) {\n            return { graphs, errors };\n        } if (includeGraphs.length !== new Set(includeGraphs).size) {\n            errors.push('Duplicate subgraph includes detected. Aborting.');\n            return { graphs, errors };\n        }\n\n        const dataflows = [];\n        await Promise.all(includeGraphs.map(async (dataflow) => {\n            const [status, val] = await loadJsonFromRemoteLocation(dataflow.url);\n            if (status === false) {\n                errors.push(`Could not load the included dataflow from '${dataflow.url}'. Reason: ${val}`);\n                return;\n            }\n\n            dataflows.push(val);\n        }));\n\n        if (errors.length) return { graphs, errors };\n\n        for (let i = 0; i < includeGraphs.length; i += 1) {\n            const dataflow = dataflows[i];\n            const dataflowMetadata = includeGraphs[i];\n\n            if (dataflow.graphs.length !== 1) {\n                errors.push(`Only single graph dataflows are supported. Aborting loading subgraph include from ${dataflowMetadata.url}.`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            const targetGraph = dataflow.graphs[0];\n            targetGraph.name = dataflowMetadata.name ?? targetGraph.name;\n\n            if (targetGraph.name === undefined) {\n                errors.push(`Included subgraph from ${dataflowMetadata.url} does not have a name defined.`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            if (graphs.find((graph) => graph.name === targetGraph.name) !== undefined) {\n                errors.push(`Included graph from ${dataflowMetadata.url} has a duplicate name`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            targetGraph.category = dataflowMetadata.category;\n            graphs.push(targetGraph);\n        }\n\n        return { graphs, errors };\n    }\n\n    /**\n     * Reads and validates part of specification related to nodes and graphs\n     * @param dataflowSpecification Specification to load\n     * @param includedGraphs Graphs included in the specification\n     * @returns An object consisting of errors and warnings arrays. If any array is empty\n     * the updating process was successful.\n     */\n    async updateGraphSpecification(dataflowSpecification) {\n        const warnings = [];\n\n        if (!dataflowSpecification) return { errors: ['No specification passed'], warnings };\n\n        const { nodes, graphs, metadata } = dataflowSpecification;\n\n        let resolvedNodes = [];\n\n        try {\n            const preprocessedNodes = this.preprocessNodes(nodes);\n            resolvedNodes = this.resolveInheritance(preprocessedNodes);\n        } catch (e) {\n            return { errors: [e.message], warnings };\n        }\n\n        const errors = [];\n        errors.push(...this.validateResolvedSpecification(\n            { graphs, nodes: resolvedNodes, metadata },\n        ));\n        if (errors.length) {\n            return { errors, warnings };\n        }\n\n        this.specification.currentSpecification.nodes = JSON.parse(JSON.stringify(resolvedNodes));\n        this.specification.currentSpecification.graphs = JSON.parse(JSON.stringify(graphs));\n\n        // Resolving siblings, parents and children\n\n        // Resolving children\n        resolvedNodes.forEach((node) => {\n            (node.extends ?? []).forEach((eName) => {\n                const extended = resolvedNodes.find((n) => n.name === eName);\n\n                // The extended node could be abstract, in which way it is not in resolved nodes.\n                if (extended !== undefined) {\n                    if (extended.extending === undefined) {\n                        extended.extending = [];\n                    }\n                    extended.extending.push(node.name);\n                }\n            });\n        });\n\n        // Resolving siblings\n        resolvedNodes.forEach((node) => {\n            const siblings = new Set();\n            (node.extends ?? []).forEach((eName) => {\n                const extended = resolvedNodes.find((n) => n.name === eName);\n\n                // The extended node could be abstract, in which way it is not in resolved nodes.\n                if (extended !== undefined) {\n                    extended.extending.forEach((e) => siblings.add(e));\n                }\n            });\n            siblings.delete(node.name);\n            node.siblings = Array.from(siblings);\n        });\n\n        // Removing abstract parents\n        resolvedNodes.forEach((node) => {\n            if (node.extends) {\n                node.extends = node.extends.filter(\n                    (eName) => (resolvedNodes.find((n) => n.name === eName) !== undefined),\n                );\n            }\n        });\n\n        resolvedNodes.forEach((node) => {\n            const myNode = NodeFactory(\n                node.name,\n                node.layer,\n                node.interfaces ?? [],\n                node.properties ?? [],\n                node.interfaceGroups ?? [],\n                node.defaultInterfaceGroups ?? [],\n                metadata?.twoColumn ?? false,\n                node.description ?? '',\n                node.extends ?? [],\n                node.extending ?? [],\n                node.siblings ?? [],\n            );\n\n            // If my node is any array then it is an array of errors\n            if (Array.isArray(myNode) && myNode.length) {\n                errors.push(...myNode);\n                return;\n            }\n\n            this.baklavaView.editor.registerNodeType(myNode, {\n                title: node.name,\n                category: node.category,\n                isCategory: node.isCategory ?? false,\n            });\n            if ('icon' in node) {\n                if (typeof node.icon === 'string') {\n                    this.baklavaView.editor.nodeIcons.set(node.name, node.icon);\n                } else {\n                    const baseName = Object.keys(node.icon)[0];\n                    const suffix = Object.values(node.icon)[0];\n                    const baseUrl = this.baklavaView.editor.baseIconUrls.get(baseName);\n                    this.baklavaView.editor.nodeIcons.set(node.name, `${baseUrl}/${suffix}`);\n                }\n            }\n            if ('urls' in node) {\n                Object.entries(node.urls).forEach(([urlName, url]) => {\n                    if (!this.baklavaView.editor.nodeURLs.has(node.name)) {\n                        this.baklavaView.editor.nodeURLs.set(node.name, {});\n                    }\n                    this.baklavaView.editor.nodeURLs.get(node.name)[urlName] = url;\n                });\n            }\n        });\n\n        if (errors.length) {\n            return { errors, warnings };\n        }\n\n        if (graphs !== undefined) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const graph of graphs) {\n                const myGraph = GraphFactory(\n                    graph.nodes,\n                    graph.connections,\n                    graph.name,\n                    this.baklavaView.editor,\n                );\n\n                // If `myGraph` is any array then it is an array of errors\n                if (Array.isArray(myGraph) && myGraph.length) {\n                    errors.push(...myGraph);\n                    continue; // eslint-disable-line no-continue\n                }\n\n                this.baklavaView.editor.addGraphTemplate(\n                    myGraph,\n                    graph.category ?? DEFAULT_GRAPH_NODE_CATEGORY,\n                    graph.name,\n                );\n\n                // Category is not needed when loading a dataflow\n                const graphToValidate = JSON.parse(JSON.stringify(graph));\n                if (Object.prototype.hasOwnProperty.call(graphToValidate, 'category')) {\n                    delete graphToValidate.category;\n                }\n\n                // Validating the graph after it is registered to see if there are any errors\n                // by loading a single graph dataflow\n\n                const {\n                    errors: loadingErrors,\n                    warnings: loadingWarnings,\n                } = await this.loadDataflow({ // eslint-disable-line no-await-in-loop\n                    graphs: [graphToValidate],\n                    version: dataflowSpecification.version,\n                }, true, true);\n\n                // Cleaning the editor after loading the dataflow\n                this.baklavaView.editor.deepCleanEditor();\n                this.baklavaView.editor.unregisterGraphs();\n\n                warnings.push(\n                    ...loadingWarnings.map((warning) => `Graph '${graph.name}' is invalid: ${warning}`),\n                );\n\n                errors.push(\n                    ...loadingErrors.map((error) => `Graph '${graph.name}' is invalid: ${error}`));\n            }\n        }\n\n        // Removing duplicate warnings\n        const uniqueWarnings = [...new Set(warnings)];\n\n        // Adding a default graph node to the editor so that custom graphs can be created\n        if (this.editor.nodeTypes.has(DEFAULT_GRAPH_NODE_TYPE)) {\n            errors.push(\n                `Node name '${DEFAULT_GRAPH_NODE_NAME}' is reserved by the editor, ` +\n                'but it was included in the specification. ' +\n                'Please change the name of the graph node to avoid conflicts.',\n            );\n            return { errors, warnings: uniqueWarnings };\n        }\n\n        const myGraph = GraphFactory(\n            [],\n            [],\n            DEFAULT_GRAPH_NODE_NAME,\n            this.baklavaView.editor,\n        );\n\n        // If `myGraph` is any array then it is an array of errors\n        if (Array.isArray(myGraph) && myGraph.length) {\n            errors.push(...myGraph);\n        } else {\n            this.baklavaView.editor.addGraphTemplate(\n                myGraph,\n                DEFAULT_GRAPH_NODE_CATEGORY,\n                DEFAULT_GRAPH_NODE_NAME,\n            );\n        }\n\n        return { errors, warnings: uniqueWarnings };\n    }\n\n    /**\n     * Preprocess nodes to be later passed to `resolveInheritance` function.\n     *\n     * @param nodes coming from specification.\n     * @throws Error if a category node has a name different than the last part of its category.\n     */\n    preprocessNodes(nodes) { // eslint-disable-line class-methods-use-this\n        nodes.forEach((node) => {\n            if (node.isCategory) {\n                const name = node.category.split('/').at(-1);\n                if (node.name !== undefined && node.name !== name) {\n                    throw new Error(`Node '${node.name}' is a category node and has a name defined different than ${name}`);\n                }\n                node.name = name;\n            }\n        });\n        return nodes;\n    }\n\n    /**\n     * Reads and validates metadata from specification and loads it into the editor.\n     * if no metadata is passed it uses a stored specification.\n     *\n     * @param metadata metadata to load\n     * @param overriding tells whether the metadata is updated on dataflow loading\n     * @param loading resets updated metadata, should be used when loading new dataflow\n     * @returns An array of errors that occurred during the metadata loading.\n     */\n    updateMetadata(metadata = undefined, overriding = false, loading = false) {\n        if (loading) this.updatedMetadata = {};\n        let newMetadata;\n        if (metadata !== undefined) {\n            metadata = { ...this.updatedMetadata, ...metadata };\n            newMetadata = JSON.parse(JSON.stringify(metadata));\n        }\n        if (metadata === undefined && this.specification.currentSpecification) {\n            metadata = this.specification.currentSpecification.metadata ?? {};\n        }\n\n        if (!metadata) return ['No specification to load provided.'];\n\n        if (overriding) {\n            // this.specification.currentSpecification?.metadata should not\n            // be over overridden, that is why it needs to be copied before merging\n            metadata = EditorManager.mergeObjects(\n                JSON.parse(JSON.stringify(\n                    this.specification.currentSpecification?.metadata ?? {},\n                )), metadata,\n            );\n        }\n\n        this.baklavaView.interfaceTypes.readInterfaceTypes(metadata);\n\n        if (metadata && 'urls' in metadata) {\n            Object.entries(metadata.urls).forEach(([urlName, state]) => {\n                this.baklavaView.editor.baseURLs.set(urlName, state);\n            });\n        }\n\n        if (metadata && 'icons' in metadata) {\n            Object.entries(metadata.icons).forEach(([iconName, state]) => {\n                this.baklavaView.editor.baseIconUrls.set(iconName, state);\n            });\n        }\n\n        if (metadata && 'navbarItems' in metadata) {\n            this.baklavaView.navbarItems = JSON.parse(JSON.stringify(metadata.navbarItems));\n        }\n\n        this.baklavaView.editor.readonly = metadata?.readonly ?? this.defaultMetadata.readonly;\n        this.baklavaView.editor.hideHud = metadata?.hideHud ?? this.defaultMetadata.hideHud;\n\n        this.editor.allowLoopbacks =\n            metadata?.allowLoopbacks ?? this.defaultMetadata.allowLoopbacks;\n        this.baklavaView.twoColumn = metadata?.twoColumn ?? this.defaultMetadata.twoColumn;\n        this.baklavaView.connectionRenderer.style =\n            metadata?.connectionStyle ?? this.defaultMetadata.connectionStyle;\n\n        this.baklavaView.movementStep = metadata?.movementStep ?? this.defaultMetadata.movementStep;\n        this.baklavaView.settings.background.gridSize =\n            metadata?.backgroundSize ?? this.defaultMetadata.backgroundSize;\n        this.baklavaView.connectionRenderer.randomizedOffset =\n            metadata?.randomizedOffset ?? this.defaultMetadata.randomizedOffset;\n\n        this.baklavaView.ignoredLayers = new Set();\n        this.baklavaView.layers = metadata?.layers ?? this.defaultMetadata.layers;\n        this.baklavaView.collapseSidebar =\n            metadata?.collapseSidebar ?? this.defaultMetadata.collapseSidebar;\n        this.baklavaView.editor.layoutManager.useAlgorithm(\n            metadata?.layout ?? this.defaultMetadata.layout,\n        );\n        this.baklavaView.logLevel = metadata?.logLevel ?? this.defaultMetadata.logLevel;\n        if (newMetadata) this.updatedMetadata = newMetadata;\n\n        return [];\n    }\n\n    /**\n     * Given nodes resolves their inheritances and returns and array of nodes that are ready\n     * to be loaded by the editor.\n     *\n     * @param nodes\n     * @returns nodes with resolved inheritances\n     */\n    /* eslint-disable class-methods-use-this,no-param-reassign */\n    resolveInheritance(nodes) {\n        const unsortedNodes = JSON.parse(JSON.stringify(nodes));\n\n        const isObject = (obj) => typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n        const isArray = (obj) => Array.isArray(obj);\n\n        // Helper function that applies base node properties to the child node\n        const mergeNodes = (child, base) => {\n            const output = { ...structuredClone(base) };\n            const nonInheritableKeys = ['abstract', 'isCategory'];\n\n            nonInheritableKeys.forEach((key) => {\n                delete output[key];\n            });\n\n            if (isObject(child) && isObject(base)) {\n                Object.keys(child).forEach((key) => {\n                    if (isObject(child[key])) {\n                        if (!(key in output)) {\n                            output[key] = child[key];\n                        } else {\n                            output[key] = mergeNodes(child[key], base[key]);\n                        }\n                    } else if (isArray(child[key]) && isArray(base[key])) {\n                        if (key === 'extends') {\n                            output[key] = child[key];\n                        } else {\n                            const baseNames = Object.fromEntries(\n                                base[key].map((obj, i) => [obj.name, i]),\n                            );\n                            child[key].forEach((obj) => {\n                                if (obj.name && obj.name in baseNames) {\n                                    const index = baseNames[obj.name];\n                                    if (obj.override) {\n                                        output[key][index] = {\n                                            ...base[key][index],\n                                            ...obj,\n                                        };\n                                        delete output[key][index].override;\n                                    } else {\n                                        throw new Error(`'${child.name}' node cannot override '${obj.name}' property of '${base.name}' node`);\n                                    }\n                                } else {\n                                    output[key].push(obj);\n                                }\n                            });\n                        }\n                    } else {\n                        output[key] = child[key];\n                    }\n                });\n            }\n            return output;\n        };\n\n        const resolvedNodes = {};\n        const recurrentMerge = (name) => {\n            // Node resolved\n            if (name in resolvedNodes) return resolvedNodes[name];\n            let node = nodes.find((n) => n.name === name);\n            // Node does not inherite anything\n            if (!node.extends) {\n                resolvedNodes[name] = node;\n                return node;\n            }\n            // Check if extends has unique values\n            if ((new Set(node.extends)).size !== node.extends.length) {\n                throw new Error(`Repeated class in \"extends\" list of \"${node.name}\" node`);\n            }\n            // Get base nodes and merge them\n            let base;\n            node.extends.forEach((baseName) => {\n                base = recurrentMerge(baseName);\n                node = mergeNodes(node, base);\n            });\n            resolvedNodes[name] = node;\n            return node;\n        };\n        // Filter out abstract nodes and get merged ones\n        const mergedNodes = unsortedNodes.filter(\n            (node) => !node.abstract,\n        ).map((node) => recurrentMerge(node.name));\n\n        return mergedNodes;\n    }\n\n    /**\n     * Serializes and returns current specification in Pipeline Manager format.\n     *\n     * @returns Serialized specification.\n     */\n    saveSpecification() {\n        return JSON.parse(JSON.stringify(this.specification.unresolvedSpecification));\n    }\n\n    /**\n     * Serializes and returns current dataflow in Pipeline Manager format.\n     *\n     * @param readonly whether the dataflow should be saved in readonly mode\n     * @param hideHud whether the dataflow should be saved in hideHud mode\n     * @param position whether the dataflow should store panning and scaling values\n     * @param graphname graph name which is rendered to the user\n     *\n     * @returns Serialized dataflow.\n     */\n    saveDataflow(readonly, hideHud, position) {\n        const save = this.baklavaView.editor.save();\n        save.version = this.specificationVersion;\n\n        if (!position) {\n            save.graphs.forEach((graph) => {\n                delete graph.panning;\n                delete graph.scaling;\n            });\n        }\n\n        if (save.metadata === undefined) {\n            save.metadata = {};\n        }\n\n        [\n            [readonly, 'readonly'],\n            [hideHud, 'hideHud'],\n            [this.editor.allowLoopbacks, 'allowLoopbacks'],\n            [this.baklavaView.twoColumn, 'twoColumn'],\n            [this.baklavaView.connectionRenderer.style, 'connectionStyle'],\n            [this.baklavaView.movementStep, 'movementStep'],\n            [this.baklavaView.settings.background.gridSize, 'backgroundSize'],\n            [this.baklavaView.connectionRenderer.randomizedOffset, 'randomizedOffset'],\n        ].forEach(([currVal, name]) => {\n            const m = this.specification.currentSpecification?.metadata ?? {};\n            const dm = this.defaultMetadata;\n\n            if (currVal !== (m[name] ?? dm[name])) {\n                save.metadata[name] = currVal;\n            }\n        });\n\n        if (Object.keys(save.metadata).length === 0) {\n            delete save.metadata;\n        }\n\n        return save;\n    }\n\n    /**\n     * Loads the dataflow passed in `dataflow` and renders it.\n     * If the dataflow is not compatible with the currently loaded specification or is not\n     * in the dataflow format, then some of the dataflow may be not loaded and an\n     * error is returned. Dataflow should be passed in PipelineManager format (translation\n     * to Baklava format is done )\n     *\n     * @param dataflow Dataflow to load. Can be eithe an object or a string\n     * @param preventCentering Boolean Blocks view in the same spot.\n     * @param loadOnly determines whether to load the graph only without adjusting\n     * the graph rendering. Can be used when validating graphs without their browser\n     * representation.\n     * @returns An array of errors that occurred during the dataflow loading.\n     * If the array is empty, the loading was successful.\n     */\n    async loadDataflow(dataflow, preventCentering = false, loadOnly = false) {\n        let { notifyWhenChanged } = this;\n        // Turn off notification during dataflow loading\n        this.updateMetadata({ notifyWhenChanged: false }, true, true);\n        try {\n            const validationErrors = EditorManager.validateDataflow(dataflow);\n            if (validationErrors.length) {\n                return { errors: validationErrors, warnings: [] };\n            }\n\n            try {\n                if (typeof dataflow === 'string' || dataflow instanceof String) {\n                    dataflow = jsonlint.parse(dataflow);\n                }\n\n                const specificationVersion = dataflow.version;\n                const warnings = [];\n                if (specificationVersion === undefined) {\n                    warnings.push(\n                        `Current format specification version is ${this.specificationVersion}. It may result in an unexpected behaviour`,\n                    );\n                } else if (specificationVersion !== this.specificationVersion) {\n                    warnings.push(\n                        `Dataflow format specification version (${specificationVersion}) differs from the current format specification version (${this.specificationVersion}). It may result in unexpected behaviour.`,\n                    );\n                }\n\n                if ('metadata' in dataflow && this.specification.currentSpecification !== undefined) {\n                    const errors = EditorManager.validateMetadata(dataflow.metadata);\n                    if (Array.isArray(errors) && errors.length) {\n                        return { errors, warnings };\n                    }\n                    notifyWhenChanged = dataflow.metadata.notifyWhenChanged ?? notifyWhenChanged;\n\n                    this.updateMetadata(\n                        { ...dataflow.metadata, notifyWhenChanged: false },\n                        true,\n                        true,\n                    );\n                }\n                if (this.baklavaView.displayedGraph !== undefined) {\n                    // Delete baklava internal history listeners\n                    this.baklavaView.history.unsubscribeFromGraphEvents(\n                        this.baklavaView.displayedGraph,\n                        Symbol('HistoryToken'),\n                    );\n                }\n                const errors = {\n                    errors: await this.baklavaView.editor.load(\n                        dataflow,\n                        preventCentering,\n                        loadOnly,\n                    ),\n                    warnings,\n                };\n                this.baklavaView.history.graphSwitch(\n                    this.baklavaView.displayedGraph,\n                    this.baklavaView.displayedGraph,\n                );\n                return errors;\n            } catch (err) {\n                return {\n                    errors: [\n                        'Unrecognized format. Make sure that the passed dataflow is correct.',\n                        err.toString(),\n                    ],\n                    warnings: [],\n                };\n            }\n        } finally {\n            // Restore previous state or use value from loaded dataflow\n            this.updateMetadata({ notifyWhenChanged }, true);\n        }\n    }\n\n    /**\n     * Static function used to get the instance of the EditorManager in a singleton manner.\n     * If there is no existing instance of the EditorManager then a new one is created.\n     *\n     * @returns Instance of EditorManager.\n     */\n    static getEditorManagerInstance() {\n        if (!EditorManager.instance) {\n            EditorManager.instance = new EditorManager();\n        }\n        return EditorManager.instance;\n    }\n\n    /**\n     * Static helper function to merge two object instances into a single.\n     * The following rules are applied:\n     * - If the property is an array then it is concatenated\n     * - If the property is an object then it is merged with preference to the first object\n     * - If the property is a simple type then it is overwritten with the first object\n     * - On type mismatch (array/object), the first object is used\n     *\n     * @param primaryObject First object to merge\n     * @param secondaryObject Second object to merge\n     * @returns Primary object with merged properties from the secondary object\n     */\n    static mergeObjects(primaryObject, secondaryObject) {\n        // Check if any of the object is undefined\n        secondaryObject = secondaryObject ?? {};\n        if (primaryObject === undefined || Object.keys(primaryObject).length === 0) {\n            return secondaryObject;\n        }\n\n        // Merge object\n        Object.entries(secondaryObject).forEach(([key, value]) => {\n            if (Array.isArray(value) && Array.isArray(primaryObject[key])) {\n                primaryObject[key].push(...value);\n            } else if (typeof value === 'object' && typeof primaryObject[key] === 'object') {\n                // For example, metadata is an object and it has to be merged instead of overwritten\n                primaryObject[key] = EditorManager.mergeObjects(primaryObject[key], value);\n            } else {\n                primaryObject[key] = value;\n            }\n        });\n        return primaryObject;\n    }\n\n    /**\n     * Validates JSON data using given JSON schema. If passed `data` is a string that represents\n     * text of specification file then more information about potential errors - like the exact\n     * line of error - is returned.\n     *\n     * @param data Specification file to validate. Can be either a parsed JSON object\n     * or a textual file\n     * @param schema Schema to use\n     * @param additionalAjvOptions Additional options to pass to the Ajv constructor\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateJSONWithSchema(data, schema, additionalAjvOptions = {}) {\n        const ajv = new Ajv2019({\n            allowUnionTypes: true,\n            formats: {\n                hex: /^0x[a-fA-F0-9]+$/,\n            },\n            schemas: [\n                unresolvedSpecificationSchema,\n                specificationSchema,\n                metadataSchema,\n                dataflowSchema,\n                graphSchema,\n            ],\n            ...additionalAjvOptions,\n        });\n        ajv.addKeyword('version');\n\n        const validate = ajv.compile(schema);\n        const isTextFormat = typeof data === 'string' || data instanceof String;\n        let dataJSON;\n\n        try {\n            dataJSON = isTextFormat ? jsonlint.parse(data) : data;\n        } catch (exception) {\n            return [`Not a proper JSON file: ${exception.toString()}`];\n        }\n\n        const valid = validate(dataJSON);\n\n        if (valid) {\n            return [];\n        }\n\n        // Parsing errors messages to a human readable string\n        const errors = validate.errors.map((error) => {\n            // It is assumed that the id of the schema is for example `dataflow_schema`\n            // Here a prefix is obtained\n            const nameOfEntity = schema.$id.split('_').slice(0, -1).join('_');\n            const path = `${nameOfEntity}${error.instancePath}`;\n            let errorPrefix = '';\n\n            if (isTextFormat) {\n                const result = jsonMap.parse(data);\n                // 1 is added as the lines are numbered from 0\n                const lineStart = result.pointers[error.instancePath].value.line + 1;\n                const lineEnd = result.pointers[error.instancePath].valueEnd.line + 1;\n\n                if (lineStart === lineEnd) {\n                    errorPrefix = `Line ${lineStart} -`;\n                } else {\n                    errorPrefix = `Lines ${lineStart}-${lineEnd} -`;\n                }\n            }\n\n            switch (error.keyword) {\n                case 'enum':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.allowedValues,\n                    )}`;\n                case 'additionalProperties':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.additionalProperty,\n                    )}`;\n                case 'const':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.allowedValue,\n                    )}`;\n                case 'unevaluatedProperties':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.unevaluatedProperty,\n                    )}}`;\n                // Those errors are not informative at all\n                case 'not':\n                case 'oneOf':\n                    return '';\n                default:\n                    return `${errorPrefix} ${path} ${error.message}`;\n            }\n        });\n\n        return errors.filter((err) => err !== '');\n    }\n\n    validateResolvedSpecification(specification) {\n        const validationErrors = EditorManager.validateSpecification(\n            specification, specificationSchema);\n        if (validationErrors.length) return validationErrors;\n\n        // Validating category nodes\n        const { nodes, graphs } = specification;\n        const categoryNodes = nodes.filter((node) => node.isCategory);\n        const definedCategories = {};\n\n        // Finding multiple category nodes defining the same category\n        const errors = [];\n        categoryNodes.forEach((node) => {\n            if (node.name in definedCategories) {\n                errors.push(`Category '${node.category}' has multiple nodes defining it.`);\n            } else {\n                definedCategories[node.name] = node.category.split('/').slice(0, -1).join('/');\n            }\n        });\n\n        // Nodes have to extend the first category node in their category path.\n        // For example, if we have two category nodes A and C and we have a node e\n        // which has a category 'A/b/C/d/e' then it has to extend C (and C has to extend A)\n        const nodeNames = new Set();\n        nodes.forEach((node) => {\n            const categories = node.category.split('/');\n\n            for (let i = categories.length - 1; i >= 0; i -= 1) {\n                const categoryNodeName = categories[i];\n                const remainingCategories = categories.slice(0, i).join('/');\n\n                if (\n                    categoryNodeName in definedCategories &&\n                    node.name !== categoryNodeName &&\n                    remainingCategories === definedCategories[categoryNodeName]\n                ) {\n                    if (node.extends === undefined || !node.extends.includes(categoryNodeName)) {\n                        errors.push(`Node '${node.name}' does not extend its category node '${categoryNodeName}'.`);\n                    }\n                    break;\n                }\n            }\n\n            // Nodes that extend from a category node have to be in their subtree i.e. have a common\n            // category prefix with the category node\n            for (let i = 0; i < (node.extends ?? []).length; i += 1) {\n                const extendedNode = node.extends[i];\n                if (extendedNode in definedCategories) {\n                    const commonPrefix = definedCategories[extendedNode] !== '' ?\n                        `${definedCategories[extendedNode]}/${extendedNode}` : extendedNode;\n\n                    if (!node.category.includes(commonPrefix)) {\n                        errors.push(\n                            `Node '${node.name}' extends from a category node '${extendedNode}' but is not in its category`,\n                        );\n                        break;\n                    }\n                }\n            }\n\n            // Finding multiple nodes with the same name\n            if (nodeNames.has(node.name)) {\n                errors.push(`Node '${node.name}' is defined multiple times`);\n            }\n            nodeNames.add(node.name);\n        });\n\n        if (graphs !== undefined) {\n            graphs.forEach((graph) => {\n                if (nodeNames.has(graph.name)) {\n                    errors.push(`Graph node name '${graph.name}' is defined multiple times`);\n                }\n                nodeNames.add(graph.name);\n            });\n        }\n        return errors;\n    }\n\n    /**\n     * Validates specification passed in `specification` using jsonSchema.\n     *\n     * @param specification Specification to validate\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateSpecification(specification, schema = unresolvedSpecificationSchema) {\n        return EditorManager.validateJSONWithSchema(specification, schema);\n    }\n\n    /**\n     * Validates metadata in JSON format using schema from unresolvedSpecificationSchema.\n     *\n     * @param jsonmetadata metadata in JSON format to validate\n     * @return An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateMetadata(jsonmetadata) {\n        return EditorManager.validateJSONWithSchema(jsonmetadata, metadataSchema);\n    }\n\n    /**\n     * Validates metadata in JSON format using schema from dataflowSchema.\n     *\n     * @param dataflow dataflow in JSON format to validate\n     * @return An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateDataflow(dataflow) {\n        return EditorManager.validateJSONWithSchema(dataflow, dataflowSchema);\n    }\n\n    /**\n     * Checks whether currently edited pipeline is one of the subgraphs\n     *\n     * @returns True if editor is editing subgraph instance, false otherwise\n     */\n    isInsideSubgraph() {\n        return this.baklavaView.displayedGraph !== this.baklavaView.editor.graph;\n    }\n\n    /**\n     * Switches the editor state to main graph\n     */\n    returnFromSubgraph() {\n        this.baklavaView.editor.backFromSubgraph(this.baklavaView.displayedGraph);\n    }\n\n    /**\n     * Updates name of currently displayed graph\n     */\n    updateSubgraphName(name) {\n        this.editor.updateCurrentSubgraphName(name);\n    }\n\n    get notifyWhenChanged() {\n        return this.updatedMetadata.notifyWhenChanged ??\n            this.specification.currentSpecification?.metadata?.notifyWhenChanged ??\n            this.defaultMetadata.notifyWhenChanged;\n    }\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n/**\n * Base class allowing to define autolayout algorithms. Each engine\n * can specify multiple algorithms, names in `availableAlgorithms` array.\n * Currently chosen algorithm is named in `activeAlgorithm`\n */\nexport default class BaseLayoutEngine {\n    availableAlgorithms = [];\n\n    // Base layout is an abstract class\n    constructor() {\n        if (this.constructor === BaseLayoutEngine) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n\n    chooseAlgorithm(algorithm) {\n        if (!this.availableAlgorithms.includes(algorithm)) {\n            throw new Error(\n                `Could not find ${algorithm} in ${this.constructor.name} engine.\n                Available algorithms: ${this.availableAlgorithms}`,\n            );\n        }\n        this.activeAlgorithm = algorithm;\n    }\n\n    /* eslint-disable class-methods-use-this */\n    /* eslint-disable no-unused-vars */\n    async calculate(graph) {\n        throw new Error('Method calculate() must be implemented by layout engine');\n    }\n}\n\n/**\n * Instance of engine with only single algorithm\n */\nexport class BaseLayoutAlgorithm extends BaseLayoutEngine {\n    constructor() {\n        super();\n        this.availableAlgorithms = [this.constructor.name];\n        this.activeAlgorithm = this.constructor.name;\n        this.chooseAlgorithm = undefined; // turn of choosing algorithm\n        if (this.constructor === BaseLayoutAlgorithm) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n */\n\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport dagre from 'cytoscape-dagre';\n\nimport BaseLayoutEngine from './baseEngine.js';\n\ncytoscape.use(dagre);\ncytoscape.use(cola);\n\nexport default class CytoscapeLayoutEngine extends BaseLayoutEngine {\n    // The only cytoscape algorithm not defined here are 'null' (every node to\n    // (0, 0)) and 'preset' (every node to user defined position)\n    availableAlgorithms = [\n        'cola',\n        'dagre-network-simplex',\n        'dagre-tight-tree',\n        'dagre-longest-path',\n        'random',\n        'grid',\n        'circle',\n        'concentric',\n        'breadthfirst',\n        'cose',\n    ];\n\n    async calculate(graph) {\n        const cytoscapeGraph = cytoscape({\n            elements: {\n                nodes: graph.nodes.map((node) => ({\n                    data: { id: node.id, width: node.width, height: node.height },\n                })),\n                edges: graph.connections.map((connection) => ({\n                    data: { id: connection.id, source: connection.from, target: connection.to },\n                })),\n            },\n            style: [\n                {\n                    selector: 'node',\n                    style: {\n                        shape: 'rectangle',\n                        width: 'data(width)',\n                        height: 'data(height)',\n                    },\n                },\n            ],\n            styleEnabled: true,\n        });\n\n        const options = { name: this.activeAlgorithm };\n        /* eslint-disable no-unused-vars */\n        switch (this.activeAlgorithm) {\n            case 'random':\n                options.boundingBox = {\n                    x1: 0,\n                    y1: 0,\n                    w: 2000,\n                    h: 2000,\n                };\n                break;\n            case 'grid':\n                options.avoidOverlapPadding = 150;\n                break;\n            case 'cose':\n                options.nodeOverlap = 1000;\n                options.idealEdgeLength = (edge) => 300;\n                break;\n            case 'cola':\n                options.nodeSpacing = (node) => 150;\n                break;\n            case 'dagre-network-simplex':\n            case 'dagre-tight-tree':\n            case 'dagre-longest-path': {\n                const [name, ...ranker] = this.activeAlgorithm.split('-');\n                options.nodeSep = 50;\n                options.rankSep = 100;\n                options.ranker = ranker.join('-');\n                options.name = name;\n                break;\n            }\n            default:\n                break;\n        }\n        /* eslint-enable no-unused-vars */\n\n        const layout = cytoscapeGraph.layout(options);\n        layout.run();\n        if (['cose', 'cola'].includes(this.activeAlgorithm)) {\n            // wait until asynchronous algorithm finish calculations\n            await layout.promiseOn('layoutstop');\n        }\n        return {\n            ...graph,\n            nodes: cytoscapeGraph.nodes().map((node) => ({\n                id: node.id(),\n                // node.position defines the center of node but graph representation\n                // required coordinates of top left corner\n                position: {\n                    x: node.position().x - node.width() / 2,\n                    y: node.position().y - node.height() / 2,\n                },\n            })),\n        };\n    }\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BaseLayoutAlgorithm } from './baseEngine.js';\n\n/**\n * Default layout algorithm that puts all nodes into (0, 0) position\n */\nexport default class NoLayoutAlgorithm extends BaseLayoutAlgorithm {\n    /* eslint-disable class-methods-use-this */\n    availableAlgorithms = [\n        'NoLayout',\n    ];\n\n    activeAlgorithm = 'NoLayout';\n\n    calculate(graph) {\n        const nodes = graph.nodes.map((node) => ({\n            ...node,\n            position: { x: 0, y: 0 },\n        }));\n        return { ...graph, nodes };\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Module handles the autolayout calculations.\n * Defines intermediate graph representation, containing:\n * - nodes - list of nodes with properties:\n *   - id - unique id\n *   - width, height - node dimensions\n *   - position - position set after the calculations with the layout engine is done.\n * - connections - list of connections in a graph, each defines property:\n *   - id - unique id\n *   - from - id of the starting node\n *   - to - id of node at the end point\n *\n * Layout Manager contains list of registered layout engines. Layout engines are\n * requested by user in a specification. If no layout engine is set, the default option\n * (setting position to (0, 0)) is used\n */\n\nimport CytoscapeLayoutEngine from './layoutEngines/cytoscapeEngine.js';\nimport NoLayoutAlgorithm from './layoutEngines/noLayoutEngine.js';\n\n/* eslint-disable no-param-reassign */\nfunction dataflowToGraph(dataflow) {\n    const interfaceToNodeId = new Map();\n    dataflow.nodes.forEach((node) => {\n        node.interfaces.forEach((intf) => interfaceToNodeId.set(intf.id, node.id));\n    });\n\n    const nodes = dataflow.nodes\n        .filter((node) => node.position === undefined)\n        .map((node) => ({\n            id: node.id,\n        }));\n    const connections = dataflow.connections\n        .filter(\n            (connection) =>\n                nodes.filter((nodeState) => nodeState.id === interfaceToNodeId.get(connection.from))\n                    .length > 0 &&\n                nodes.filter((nodeState) => nodeState.id === interfaceToNodeId.get(connection.to))\n                    .length > 0,\n        )\n        .map((connection) => ({\n            id: connection.id,\n            from: interfaceToNodeId.get(connection.from),\n            to: interfaceToNodeId.get(connection.to),\n        }));\n    return { nodes, connections };\n}\n\nfunction graphToDataflow(graph, dataflow) {\n    const idToPosition = new Map();\n    graph.nodes.forEach((node) => idToPosition.set(node.id, node.position));\n    dataflow.nodes = dataflow.nodes.map((node) => ({\n        ...node,\n        position: idToPosition.has(node.id) ? idToPosition.get(node.id) : node.position,\n    }));\n    return dataflow;\n}\n\nexport default class LayoutManager {\n    layoutEngine = undefined;\n\n    usedAlgorithm = undefined;\n\n    graph = undefined;\n\n    // Default option when no layout algorithm is specified\n    // Currently it is possible to register it, when more layout algorithms\n    // are added it should be 1) automatically registered 2) not possible to\n    // choose in available algorithms\n    availableEngines = {\n        NoLayout: new NoLayoutAlgorithm(),\n        CytoscapeEngine: new CytoscapeLayoutEngine(),\n    };\n\n    constructor() {\n        this.useAlgorithm('NoLayout');\n    }\n\n    useAlgorithm(algorithm) {\n        const [engineName, algorithmName] = algorithm.split(' - ');\n        const layoutEngine = this.availableEngines[engineName];\n        if (layoutEngine === undefined) {\n            throw new Error(`Could not parse the ${algorithm} autolayout algorithm`);\n        }\n        this.layoutEngine = layoutEngine;\n        if (algorithmName !== undefined) {\n            this.layoutEngine.chooseAlgorithm(algorithmName);\n        }\n        this.usedAlgorithm = algorithm;\n    }\n\n    getAvailableAlgorithms() {\n        return Object.entries(this.availableEngines)\n            .map(([engineName, engine]) => {\n                if (engine.availableAlgorithms.length !== 1) {\n                    return engine.availableAlgorithms.map(\n                        (algorithm) => `${engineName} - ${algorithm}`,\n                    );\n                }\n                return engineName;\n            })\n            .flat();\n    }\n\n    registerGraph(dataflow) {\n        this.graph = dataflowToGraph(dataflow);\n    }\n\n    async computeLayout(dataflow) {\n        this.updateDimensions();\n        const layout = await this.runEngine(this.graph);\n        return graphToDataflow(layout, dataflow);\n    }\n\n    async runEngine(graph) {\n        return this.layoutEngine.calculate(graph);\n    }\n\n    updateDimensions() {\n        this.graph.nodes = this.graph.nodes.map((node) => {\n            const HTMLelement = document.getElementById(node.id);\n            return {\n                ...node,\n                width: HTMLelement.offsetWidth,\n                height: HTMLelement.offsetHeight,\n            };\n        });\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CheckboxInterface,\n    IntegerInterface,\n    NumberInterface,\n    SelectInterface,\n    TextInterface,\n} from '@baklavajs/renderer-vue';\n\nimport { defineNode, GraphTemplate, NodeInterface } from '@baklavajs/core';\n\nimport { updateInterfacePosition } from '../custom/CustomNode.js';\nimport { applySidePositions, parseInterfaces, validateInterfaceGroups } from './interfaceParser.js';\n\nimport InputInterface from '../interfaces/InputInterface.js';\nimport ListInterface from '../interfaces/ListInterface.js';\nimport SliderInterface from '../interfaces/SliderInterface.js';\nimport HexInterface from '../interfaces/HexInterface.js';\nimport { ir } from './interfaceRegistry.ts';\n\n/**\n * @param properties coming from the specification\n * @returns object that can be used to create properties or an array of errors\n * if any occurred.\n */\nfunction parseProperties(properties) {\n    const parsedProperties = {};\n    const usedNames = new Set();\n    const errors = [];\n\n    properties.forEach((prop) => {\n        if (prop.group !== undefined) {\n            const parsedGroup = parseProperties(prop.group);\n            if (Array.isArray(parsedGroup) && parsedGroup.length) {\n                errors.push(...parsedGroup);\n            }\n\n            Object.entries(parsedGroup).forEach(([pgroupname]) => {\n                if (usedNames.has(pgroupname)) {\n                    const realname = pgroupname.slice(pgroupname.indexOf('_') + 1);\n                    errors.push(\n                        `Property named '${realname}' in a group property '${prop.name}' is a duplicate.`,\n                    );\n                }\n                usedNames.add(pgroupname);\n            });\n\n            prop.group = parsedGroup; // eslint-disable-line no-param-reassign\n        }\n\n        if (usedNames.has(`property_${prop.name}`)) {\n            errors.push(\n                `Property named '${prop.name}' is a duplicate.`,\n            );\n        }\n\n        parsedProperties[`property_${prop.name}`] = { ...prop };\n        usedNames.add(`property_${prop.name}`);\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return parsedProperties;\n}\n\n/**\n * @param properties that are validated and parsed\n * @returns created properties\n */\nfunction createProperties(properties) {\n    const getIntf = (p, hidden = false) => {\n        const propName = p.name;\n        const propType = p.type;\n        let propDef = p.default;\n        let intf;\n\n        switch (propType) {\n            case 'constant':\n                intf = new TextInterface(propName, propDef).setPort(false);\n                intf.componentName = 'TextInterface';\n                break;\n            case 'text':\n                intf = new InputInterface(propName, propDef).setPort(false);\n                intf.componentName = 'InputInterface';\n                break;\n            case 'number':\n                intf = new NumberInterface(propName, propDef).setPort(false);\n                intf.componentName = 'NumberInterface';\n                break;\n            case 'integer':\n                intf = new IntegerInterface(propName, propDef).setPort(false);\n                intf.componentName = 'IntegerInterface';\n                break;\n            case 'hex':\n                intf = new HexInterface(\n                    propName,\n                    propDef.toLowerCase(),\n                    p.min ? BigInt(p.min) : NaN,\n                    p.max ? BigInt(p.max) : NaN,\n                ).setPort(false);\n                intf.componentName = 'HexInterface';\n                break;\n            case 'select': {\n                const it = p.values.map((element) => element.toString());\n                intf = new SelectInterface(propName, propDef, it).setPort(false);\n                intf.componentName = 'SelectInterface';\n            } break;\n            case 'bool':\n                intf = new CheckboxInterface(propName, propDef).setPort(false);\n                intf.componentName = 'CheckboxInterface';\n                break;\n            case 'slider':\n                if (propDef === undefined) {\n                    propDef = p.min;\n                }\n                intf = new SliderInterface(propName, propDef, p.min, p.max, p.step).setPort(\n                    false,\n                );\n                intf.componentName = 'SliderInterface';\n                break;\n            case 'list':\n                if (propDef === null) {\n                    propDef = [];\n                }\n                intf = new ListInterface(propName, propDef, p.dtype).setPort(false);\n                intf.componentName = 'ListInterface';\n                break;\n            default:\n                /* eslint-disable no-console */\n                console.error(propType, ' input type is not recognized.');\n        }\n        if (intf !== undefined) {\n            intf.hidden = hidden;\n            intf.type = propType;\n        }\n\n        return intf;\n    };\n\n    const tempProperties = {};\n\n    Object.entries(properties).forEach(([pname, p]) => {\n        if (p.group !== undefined) {\n            tempProperties[pname] = (() => {\n                const groupedProperty = getIntf(p);\n                groupedProperty.group = Object.keys(p.group);\n                return groupedProperty;\n            });\n            Object.entries(p.group).forEach(([pgroupname, pgroup]) => {\n                tempProperties[pgroupname] = () => getIntf(pgroup);\n            });\n        } else {\n            tempProperties[pname] = () => getIntf(p);\n        }\n    });\n    return tempProperties;\n}\n\n/**\n * Function performs sanity checking on parsed state before loading it\n * into the editor. It should throw explicit errors if any discrepancy is detected.\n *\n * @param parsedState that is passed to node to load\n * @param inputs inputs of the node\n * @param outputs outputs of the node\n * @returns list of errors.\n */\nfunction detectDiscrepancies(parsedState, inputs, outputs) {\n    let errors = [];\n\n    const checkType = (propType, value) => {\n        switch (propType) {\n            case 'constant':\n            case 'select':\n                return true;\n            case 'text':\n            case 'hex':\n                return typeof value === 'string';\n            case 'number':\n            case 'integer':\n            case 'slider':\n                return typeof value === 'number';\n            case 'bool':\n                return typeof value === 'boolean';\n            case 'list':\n                return Array.isArray(value);\n            default:\n                return false;\n        }\n    };\n\n    // Checking for existence of interfaces defined\n    Object.keys({\n        ...parsedState.inputs,\n        ...parsedState.outputs,\n    }).forEach((ioName) => {\n        const name = ioName.slice(ioName.indexOf('_') + 1);\n        const direction = ioName.slice(0, ioName.indexOf('_'));\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, ioName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, ioName)\n        ) {\n            if (direction === 'property') {\n                errors.push(`Property named '${name}' not found in specification!`);\n            } else {\n                errors.push(`Interface named '${name}' of direction '${direction}' not found in specification!`);\n            }\n        } else if (direction === 'property') {\n            // Verifying property type defined in the node and the value passed\n            const parsedValue = parsedState.inputs[ioName].value;\n            const propertyType = inputs[ioName].type;\n            if (!checkType(propertyType, parsedValue)) {\n                errors.push(`Property '${name}' type mismatch. ${propertyType} expected, ${typeof parsedValue} found.`);\n            } else if (propertyType === 'select' && !inputs[ioName].items.includes(parsedValue)) {\n                errors.push(`Property '${name}' value mismatch. ${parsedValue} not found in ${inputs[ioName].items}`);\n            } else if (propertyType === 'list') {\n                const { dtype } = inputs[ioName];\n                const mismatchedElements = parsedValue.filter((val) => typeof val !== dtype); // eslint-disable-line valid-typeof,max-len\n                if (mismatchedElements.length > 0) {\n                    errors.push(`Property '${name}' value mismatch. Items: '${mismatchedElements.join(' ')}' are not of '${dtype}' dtype.`);\n                }\n            }\n        }\n    });\n\n    // Checking for existence of interface groups\n    Object.keys(parsedState.enabledInterfaceGroups).forEach((groupName) => {\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, groupName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, groupName)\n        ) {\n            const direction = groupName.slice(0, groupName.indexOf('_'));\n            const name = groupName.slice(groupName.indexOf('_') + 1);\n\n            errors.push(`Interface group named '${name}' of direction '${direction}' not found in specification!`);\n        }\n    });\n\n    if (errors && errors.length) {\n        return errors;\n    }\n\n    errors = validateInterfaceGroups(\n        Object.keys(parsedState.enabledInterfaceGroups),\n        inputs,\n        outputs,\n    );\n\n    return errors;\n}\n\n/**\n * @param state state to be loaded. Should be a valid dataflow\n * @returns state that can be given to baklavajs, or an array of errors if any occurred\n */\nfunction parseNodeState(state) {\n    const newState = JSON.parse(JSON.stringify(state));\n\n    if (newState.interfaces !== undefined) {\n        const out = parseInterfaces(newState.interfaces, [], []);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        const { inputs, outputs } = out;\n        newState.inputs = inputs;\n        newState.outputs = outputs;\n\n        delete newState.interfaces;\n    }\n\n    if (newState.properties !== undefined) {\n        const out = parseProperties(newState.properties);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        newState.inputs = { ...newState.inputs, ...out };\n        delete newState.properties;\n    }\n\n    if (newState.enabledInterfaceGroups !== undefined) {\n        const interfaceGroups = {};\n        newState.enabledInterfaceGroups.forEach((intf) => {\n            interfaceGroups[`${intf.direction}_${intf.name}`] = { ...intf };\n        });\n        newState.enabledInterfaceGroups = interfaceGroups;\n    } else {\n        newState.enabledInterfaceGroups = {};\n    }\n\n    newState.title = newState.instanceName ?? '';\n    delete newState.instanceName;\n\n    newState.parsed = true;\n    return newState;\n}\n\n/**\n * Class factory that creates a class for a custom Node that is described by the arguments.\n * It can be later registered so that the user can use it and save the editor.\n * `inputs`, `properties` and `outputs` formats are described in the documentation.\n *\n * @param {string} name Name of the block that is stored when saving\n * @param {string} layer Layer of the node\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} properties List of properties of the block\n * @param {*} interfaceGroups Object describing groups of interfaces\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that\n * are enabled by default\n * @param {boolean} twoColumn type of layout of the nodes\n * @returns Node based class is successful, otherwise an array of errors is returned.\n */\nexport function NodeFactory(\n    name,\n    layer,\n    interfaces,\n    properties,\n    interfaceGroups,\n    defaultInterfaceGroups,\n    twoColumn,\n    description = '',\n    nodeExtends = [],\n    nodeExtending = [],\n    nodeSiblings = [],\n) {\n    const parsedInterfaces = parseInterfaces(interfaces, interfaceGroups, defaultInterfaceGroups);\n    // If parsedInterfaces returns an array, it is an array of errors\n    if (Array.isArray(parsedInterfaces) && parsedInterfaces.length) {\n        return parsedInterfaces.map((error) => `Node ${name} invalid. ${error}`);\n    }\n\n    function createBaklavaInterface(intf) {\n        return () => {\n            const baklavaIntf = new NodeInterface(intf.name);\n            Object.assign(baklavaIntf, intf);\n            return baklavaIntf;\n        };\n    }\n\n    // Creating interfaces for baklavajs\n    const inputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.inputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    const outputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.outputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    const parsedProperties = parseProperties(properties);\n    // If parsedProperties returns an array, it is an array of errors\n    if (Array.isArray(parsedProperties) && parsedProperties.length) {\n        return parsedProperties.map((error) => `Node ${name} invalid. ${error}`);\n    }\n    const createdProperties = createProperties(parsedProperties);\n\n    const node = defineNode({\n        type: name,\n\n        inputs: {\n            ...inputs,\n            ...createdProperties,\n        },\n        outputs,\n\n        /* eslint-disable no-param-reassign */\n        onCreate() {\n            this.description = description;\n            this.extends = nodeExtends;\n            this.extending = nodeExtending;\n            this.siblings = nodeSiblings;\n            this.layer = layer;\n            this.parentSave = this.save;\n            this.parentLoad = this.load;\n            this.title = name;\n\n            /**\n             * Toggles interface groups and removes any connections attached\n             * to the interface it is toggled to hidden.\n             *\n             * @param intf interface instance of the interface group\n             * @param {bool} visible whether to enable or disable interface group\n             */\n            this.toggleInterfaceGroup = (intf, visible) => {\n                // If the interface is visible and is being disabled\n\n                if (!intf.hidden && !visible) {\n                    const connections = this.graphInstance.connections.filter(\n                        (c) => c.from === intf || c.to === intf,\n                    );\n                    connections.forEach((c) => {\n                        this.graphInstance.removeConnection(c);\n                    });\n                }\n\n                // checking if there is an interface with the same side position\n                if (visible) {\n                    updateInterfacePosition(this, intf, intf.side);\n                }\n                // It may also need a new sidePosition\n                intf.hidden = !visible;\n            };\n\n            this.save = () => {\n                const savedState = this.parentSave();\n                const newProperties = [];\n                const newInterfaces = [];\n                const enabledInterfaceGroups = [];\n\n                Object.entries({ ...this.inputs, ...this.outputs }).forEach((io) => {\n                    const [ioName, ioState] = io;\n\n                    if (ioState.port) {\n                        if (!ioState.hidden) {\n                            if (ioState.interfaces) {\n                                // Enabled interface groups\n                                enabledInterfaceGroups.push({\n                                    name: ioName.slice(ioState.direction.length + 1),\n                                    direction: ioState.direction,\n                                });\n                            }\n\n                            newInterfaces.push({\n                                name: ioName.slice(ioState.direction.length + 1),\n                                externalName: ioState.externalName,\n                                id: ioState.id,\n                                direction: ioState.direction,\n                                side: ioState.side,\n                                sidePosition: ioState.sidePosition,\n                            });\n                        }\n                    } else {\n                        newProperties.push({\n                            name: ioName.slice('property'.length + 1),\n                            id: ioState.id,\n                            value: ioState.value === undefined ? null : ioState.value,\n                        });\n                    }\n                });\n\n                delete savedState.inputs;\n                delete savedState.outputs;\n                savedState.interfaces = newInterfaces;\n                savedState.properties = newProperties;\n                savedState.enabledInterfaceGroups = enabledInterfaceGroups;\n\n                savedState.name = savedState.type;\n                delete savedState.type;\n\n                savedState.instanceName = savedState.title === '' ? undefined : savedState.title;\n                delete savedState.title;\n\n                return savedState;\n            };\n\n            /**\n             * Function used to update interfaces of a node when loading a dataflow\n             * in a development mode.\n             */\n            this.updateInterfaces = (stateInputs, stateOutputs) => {\n                const errors = [];\n                // Updating interfaces of a graph node\n                Object.entries(this.inputs).forEach(([k, intf]) => {\n                    // Process only interfaces, not properties\n                    if (intf.direction === undefined) return;\n                    if (!Object.keys(stateInputs).includes(k)) {\n                        errors.push(\n                            `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                            `removed as it was not found in the dataflow.`,\n                        );\n                        this.removeInput(k);\n                    }\n                });\n                Object.entries(stateInputs).forEach(([idA, intfA]) => {\n                    if (intfA.direction === undefined) return;\n                    const foundIntf = Object.entries(this.inputs).find(\n                        ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n                    );\n                    if (foundIntf === undefined) {\n                        const baklavaIntf = new NodeInterface(idA);\n                        errors.push(\n                            `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                            `created as it was not found in the specification.`,\n                        );\n                        Object.assign(baklavaIntf, intfA);\n                        this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n                    } else {\n                        Object.assign(foundIntf[1], intfA);\n                    }\n                });\n\n                Object.entries(this.outputs).forEach(([k, intf]) => {\n                    // Process only interfaces, not properties\n                    if (intf.direction === undefined) return;\n                    if (!Object.keys(stateOutputs).includes(k)) {\n                        errors.push(\n                            `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                            `removed as it was not found in the dataflow.`,\n                        );\n                        this.removeOutput(k);\n                    }\n                });\n                Object.entries(stateOutputs).forEach(([idA, intfA]) => {\n                    const foundIntf = Object.entries(this.outputs).find(\n                        ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n                    );\n                    if (foundIntf === undefined) {\n                        const baklavaIntf = new NodeInterface(idA);\n                        errors.push(\n                            `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                            `created as it was not found in the specification.`,\n                        );\n                        Object.assign(baklavaIntf, intfA);\n                        this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n                    } else {\n                        Object.assign(foundIntf[1], intfA);\n                    }\n                });\n                return errors;\n            };\n\n            this.updateProperties = (stateProperties) => {\n                const errors = [];\n                // Updating properties of a graph node\n                Object.entries(this.inputs).forEach(([k, prop]) => {\n                    // Process only properties, not interfaces\n                    if (prop.direction !== undefined) return;\n                    if (!Object.keys(stateProperties).includes(k)) {\n                        errors.push(\n                            `Property '${prop.name}' ` +\n                            `removed as it was not found in the dataflow.`,\n                        );\n                        this.removeInput(k);\n                    }\n                });\n                Object.entries(stateProperties).forEach(([idA, propA]) => {\n                    if (propA.direction !== undefined) return;\n                    const foundProp = Object.entries(this.inputs).find(\n                        ([idB]) => idB === idA,\n                    );\n                    if (foundProp === undefined) {\n                        const baklavaProp = new InputInterface(\n                            propA.name,\n                            propA.value,\n                        ).setPort(false);\n                        baklavaProp.componentName = 'InputInterface';\n                        errors.push(\n                            `Property '${propA.name}' ` +\n                            `created as it was not found in the specification.`,\n                        );\n                        Object.assign(baklavaProp, propA);\n                        this.addInput(idA, baklavaProp);\n                    }\n                });\n                return errors;\n            };\n\n            this.load = (state) => {\n                let parsedState;\n\n                // `parsed` determines whether the state was already parsed before loading\n                // This is caused by the fact that `load` can be used both to load a state\n                // from a dataflow and from an instance of a node\n                if (Object.prototype.hasOwnProperty.call(state, 'parsed') && state.parsed) {\n                    parsedState = state;\n                } else {\n                    parsedState = parseNodeState(state);\n\n                    if (Array.isArray(parsedState) && parsedState.length) {\n                        return parsedState.map((error) => `Node ${name} of id: ${this.id} invalid. ${error}`);\n                    }\n                }\n\n                let errors = [];\n                if (process.env.VUE_APP_GRAPH_DEVELOPMENT_MODE === 'true') {\n                    errors = this.updateInterfaces(parsedState.inputs, parsedState.outputs);\n                    errors = [...errors, ...this.updateProperties(parsedState.inputs)];\n                    errors = errors.map((error) => `Node ${name} of id: ${this.id} invalid. ${error}`);\n                } else {\n                    errors = detectDiscrepancies(parsedState, this.inputs, this.outputs);\n                    if (Array.isArray(errors) && errors.length) {\n                        return errors.map((error) => `Node ${name} of id: ${this.id} invalid. ${error}`);\n                    }\n                }\n\n                this.parentLoad(parsedState);\n\n                // Disabling default interface groups if the node has its own state\n                if (Object.keys(parsedState.enabledInterfaceGroups).length) {\n                    Object.entries({ ...this.inputs, ...this.outputs }).forEach(([, intf]) => {\n                        // If this is an interfaces group\n                        if (intf.interfaces !== undefined) {\n                            intf.hidden = true;\n                        }\n                    });\n                }\n\n                // Enabling interface groups\n                Object.entries(parsedState.enabledInterfaceGroups).forEach(\n                    ([groupName, groupState]) => {\n                        if (groupState.direction === 'input' || groupState.direction === 'inout') {\n                            this.inputs[groupName].hidden = false;\n                        } else if (groupState.direction === 'output') {\n                            this.outputs[groupName].hidden = false;\n                        }\n                    },\n                );\n\n                const occupied = { left: [], right: [] };\n\n                const stateios = { ...parsedState.inputs, ...parsedState.outputs };\n\n                // Assigning sides and sides Positions to interfaces\n                Object.entries(stateios).forEach(([ioName, ioState]) => {\n                    if (ioState.direction === 'input' || ioState.direction === 'inout') {\n                        this.inputs[ioName].side = ioState.side;\n                        this.inputs[ioName].sidePosition = ioState.sidePosition;\n                        this.inputs[ioName].externalName = ioState.externalName;\n                        occupied[ioState.side].push(ioState.sidePosition);\n                    } else if (ioState.direction === 'output') {\n                        this.outputs[ioName].side = ioState.side;\n                        this.outputs[ioName].sidePosition = ioState.sidePosition;\n                        this.outputs[ioName].externalName = ioState.externalName;\n                        occupied[ioState.side].push(ioState.sidePosition);\n                    }\n                });\n\n                const refreshSidePositions = (entries) => {\n                    // When state provided in the graph is incomplete, e.g. it misses\n                    // an interface, we allow it.\n                    // This, however, requires from us that we make sure that newly added\n                    // interfaces (not present in parsedState) are not on conflicting positions\n                    Object.entries(entries).forEach(([ioName, ioState]) => {\n                        if (ioName.startsWith('property_')) return;\n                        // if interface was explicitly defined in the graph file, skip it\n                        if (ioName in stateios) return;\n                        // otherwise, if the interface was implicitly created but it does not\n                        // cover existing interface, skip it\n                        if (!occupied[ioState.side].includes(ioState.sidePosition)) return;\n                        // if the positions are clashing, pick first available max position on\n                        // given side\n                        const maxposition = Math.max(...occupied[ioState.side]);\n                        ioState.sidePosition = maxposition + 1;\n                        occupied[ioState.side].push(maxposition + 1);\n                    });\n                };\n\n                refreshSidePositions(this.inputs);\n                refreshSidePositions(this.outputs);\n\n                // Default position should be undefined instead of (0, 0) so that it can be set\n                // by autolayout\n                if (state.position === undefined) {\n                    this.position = undefined;\n                }\n                return errors;\n            };\n\n            this.twoColumn = twoColumn;\n        },\n        onDestroy() {\n            [...Object.values(this.inputs), ...Object.values(this.outputs)].forEach((io) => {\n                Object.values(io.events).forEach((event) => {\n                    // We need to unsubscribe from all events to avoid memory leaks\n                    // On token mismatch, the event will not be unsubscribed\n                    event.unsubscribe(io);\n                });\n            });\n        },\n    });\n\n    return node;\n}\n\n/**\n * Function looks for graph node interfaces based on the nodes inside of it.\n *\n * It finds all interfaces that have `externalName` property set and registers\n * them in the InterfaceRegistry, if they are not already registered, so that\n * they their state can be easily shared and synchronized.\n *\n * If there are any errors, they are returned as an array of strings.\n * If the operation was successful, the new inputs and outputs are returned.\n *\n * @param nodes Nodes of the subgraph\n * @param inputs List of inputs of the subgraph\n * @param outputs List of outputs of the subgraph\n *\n * @returns List of errors or new inputs and outputs\n */\nexport function updateSubgraphInterfaces(nodes, inputs = [], outputs = []) {\n    // Interfaces that are not connected to any other interface\n    const INTERFACE_PREFIXES = ['input_', 'inout_', 'output_'];\n\n    const exposedIntf = [\n        ...nodes.map((node) => Object.entries({ ...node.inputs, ...node.outputs })).flat(),\n    ].filter(([key]) => INTERFACE_PREFIXES.some((prefix) => key.startsWith(prefix)))\n        .filter(\n            ([, intf]) => intf.externalName,\n        );\n\n    // Filter out repeated external names\n    const countedIntfNames = Object.create(null);\n    const externalInterfaces = [];\n    exposedIntf.forEach(\n        ([, intf]) => {\n            countedIntfNames[intf.externalName] = (countedIntfNames[intf.externalName] ?? 0) + 1;\n            if (countedIntfNames[intf.externalName] === 1) {\n                externalInterfaces.push(intf);\n            } else {\n                externalInterfaces.push(`Interface '${intf.externalName}' is repeated ${countedIntfNames[intf.externalName]} times.`);\n            }\n        },\n    );\n    const errorMessages = externalInterfaces.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    // Create new inputs and outputs\n    const newInterfaces = [];\n    externalInterfaces.forEach((intf) => {\n        const graphId = nodes[0].graph.id;\n        // It may happen that the registered interface has the same id, but is a reference,\n        // for example when dealing with history or clipboard.\n        if (\n            ir.isRegistered(intf.id) &&\n            ir.getRegisteredInterface(intf.id).sharedInterface !== intf &&\n            ir.getRegisteredInterface(intf.id).sharedInterface.id === intf.id &&\n            ir.getRegisteredInterface(intf.id).sharedInterfaceGraphId === graphId\n        ) {\n            ir.deleteRegisteredInterface(intf.id);\n        }\n\n        if (!ir.isRegistered(intf.id)) {\n            ir.registerInterface(intf, graphId);\n        }\n\n        const container = intf.direction === 'output' ? outputs : inputs;\n        const idx = container.findIndex((x) => x.id === intf.id);\n        if (idx === -1) {\n            // Graph node interface should not inherit some properties that\n            // are node-specific, they will be accessed using InterfaceRegistry\n            newInterfaces.push({\n                name: intf.externalName,\n                id: intf.id,\n                externalName: undefined,\n                side: intf.side,\n                direction: intf.direction,\n                sidePosition: undefined,\n            });\n        } else {\n            container[idx].name = intf.externalName;\n            newInterfaces.push(container[idx]);\n        }\n    });\n\n    const newInterfacesPositionsOrErrors = applySidePositions(newInterfaces, {});\n    if (Array.isArray(newInterfacesPositionsOrErrors) && newInterfacesPositionsOrErrors.length) {\n        return newInterfacesPositionsOrErrors;\n    }\n\n    return {\n        inputs: Object.values(newInterfacesPositionsOrErrors.inputs),\n        outputs: Object.values(newInterfacesPositionsOrErrors.outputs),\n    };\n}\n\n/**\n * Function creating a graph template as defined in specification\n *\n * @param nodes Nodes of the subgraph\n * @param connections Connections inside the subgraph\n * @param name Default name that will be displayed in editor\n * @param editor PipelineManagerEditor instance\n * @returns Graph template that will be used to define the subgraph node\n */\nexport function GraphFactory(nodes, connections, name, editor) {\n    const parsedState = nodes.map((node) => parseNodeState(node));\n    const errorMessages = parsedState.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    const state = {\n        name,\n        nodes: parsedState,\n        connections,\n        inputs: [],\n        outputs: [],\n    };\n\n    return new GraphTemplate(state, editor);\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable import/prefer-default-export */\nconst getBackendApiUrl = () => {\n    if (window.location.protocol === 'file:' ||\n        (process.env.VUE_APP_STATIC !== undefined && process.env.VUE_APP_STATIC === 'true'))\n        return null;\n    if (process.env.VUE_APP_COMMUNICATION_SERVER_HOST !== undefined &&\n        process.env.VUE_APP_COMMUNICATION_SERVER_HOST !== undefined)\n        return `http://${process.env.VUE_APP_COMMUNICATION_SERVER_HOST}:${process.env.VUE_APP_COMMUNICATION_SERVER_PORT}`;\n    return `${window.location.protocol}//${window.location.host}`;\n};\nexport const backendApiUrl = getBackendApiUrl();\nexport const HTTPCodes = {\n    OK: 200,\n    BadRequest: 400,\n    ServiceUnavailable: 503,\n};\nexport const PMMessageType = {\n    OK: 0,\n    ERROR: 1,\n    PROGRESS: 2,\n    WARNING: 3,\n};\nexport const JSONRPCCustomErrorCode = {\n    EXCEPTION_RAISED: -1,\n    EXTERNAL_APPLICATION_NOT_CONNECTED: -2,\n    NEWER_SESSION_AVAILABLE: -3,\n};\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\n/*\n * This module contains all possible JSON-RPC requests that frontend can\n * receive and process.\n *\n * Each exported function is automatically registered as JSON-RPC method\n * when JSON-RPC server is created in fetchRequest.\n * Function name have to match with specification (resources/api_specification).\n */\nimport { useViewModel } from '@baklavajs/renderer-vue';\nimport runInfo from './runInformation';\nimport EditorManager from '../EditorManager';\nimport NotificationHandler from '../notifications';\nimport { terminalStore } from '../stores';\n/* eslint-disable import/prefer-default-export */\n/* eslint-disable camelcase */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst editorManager = EditorManager.getEditorManagerInstance();\n/**\n * Finds graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @returns found graph\n */\nfunction getGraph(graph_id) {\n    const { viewModel } = useViewModel();\n    const graph = [...viewModel.value.editor.graphs].find((g) => g.id === graph_id);\n    if (graph === undefined) {\n        throw new Error(`Graph with id '${graph_id}' does not exist.`);\n    }\n    return graph;\n}\n/**\n * Finds node of id `node_id` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param node_id Id of a node to find\n * @returns found node\n */\nfunction getNode(graph_id, node_id) {\n    const graph = getGraph(graph_id);\n    const node = graph.nodes.find((n) => n.id === node_id);\n    if (node === undefined) {\n        throw new Error(`Node with id '${node_id}' does not exist.`);\n    }\n    return node;\n}\n/**\n * Finds property of id `id` or name `name` in node.\n * One of those values has to be defined.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param node Node instance that is searched\n * @param id id of the property\n * @param name name of the property\n * @returns found property\n */\nfunction getProperty(node, id, name) {\n    let prop;\n    if (id !== undefined) {\n        prop = Object.values(node.inputs).find((p) => p.id === id);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with id '${id}' does not exist.`);\n        }\n    }\n    else {\n        prop = Object.values(node.inputs).find((p) => p.name === name);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with name '${name}' does not exist.`);\n        }\n    }\n    return prop;\n}\n/**\n * Finds connection between interfaces with id `from` and `to` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param from Id of a first interface\n * @param to Id of a second interface\n * @returns found node\n */\nfunction getConnection(graph_id, from, to) {\n    const graph = getGraph(graph_id);\n    const connection = graph.connections.find((c) => c.from.id === from && c.to.id === to);\n    if (connection === undefined) {\n        throw new Error(`Connection from ${from} to ${to} does not exist.`);\n    }\n    return connection;\n}\n/**\n * @returns currently used dataflow\n */\nexport function graph_get() {\n    return {\n        dataflow: editorManager.saveDataflow(),\n    };\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    // First iteration to validate that every property exists\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        getProperty(node, property.id, property.name);\n    }\n    // Second iteration to actually alter the values\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        const prop = getProperty(node, property.id, property.name);\n        prop.value = property.new_value;\n    }\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function position_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    node.position.x = params.position.x;\n    node.position.y = params.position.y;\n}\n/**\n * Creates and deletes nodes based on received `params`.\n */\nexport function nodes_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { viewModel } = useViewModel();\n        const graph = getGraph(params.graph_id);\n        params.nodes.added.forEach((n) => {\n            const info = viewModel.value.editor.nodeTypes.get(n.name);\n            if (!info) {\n                throw new Error(`Node type not found for name ${n.name}`);\n            }\n            else {\n                const node = new info.type(); // eslint-disable-line new-cap\n                node.id = n.id;\n                graph.addNode(node);\n                const errors = node.load(n);\n                if (Array.isArray(errors) && errors.length)\n                    throw new Error(errors.join('\\n'));\n            }\n        });\n        params.nodes.deleted.forEach((n) => {\n            var _a;\n            const node = getNode(params.graph_id, n);\n            if ((_a = params.remove_with_connections) !== null && _a !== void 0 ? _a : true) {\n                graph.removeNode(node);\n            }\n            else {\n                graph.removeNodeOnly(node);\n            }\n        });\n    });\n}\n/**\n * Creates and deletes connections based on received `params`.\n */\nexport function connections_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const graph = getGraph(params.graph_id);\n        params.connections.added.forEach((c) => {\n            const fromIntf = graph.findNodeInterface(c.from);\n            if (!fromIntf)\n                throw new Error(`Interface with id ${c.from} does not exist`);\n            const toIntf = graph.findNodeInterface(c.to);\n            if (!toIntf)\n                throw new Error(`Interface with id ${c.to} does not exist`);\n            const connection = graph.addConnection(fromIntf, toIntf);\n            if (!connection)\n                throw new Error(`Connection from ${c.from} to ${c.to} cannot be created`);\n        });\n        params.connections.deleted.forEach((c) => {\n            graph.removeConnection(getConnection(params.graph_id, c.from, c.to));\n        });\n    });\n}\n/**\n * Loads received dataflow.\n */\nexport function graph_change(params) {\n    editorManager.loadDataflow(params.dataflow);\n}\n/**\n * Returns an array of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        const properties = [];\n        if (params.properties === undefined) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const property of Object.values(node.inputs)) {\n                if (property.side === undefined) {\n                    properties.push({\n                        id: property.id,\n                        name: property.name,\n                        value: property.value,\n                    });\n                }\n            }\n            return properties;\n        }\n        // eslint-disable-next-line no-restricted-syntax\n        for (const property of params.properties) {\n            const prop = getProperty(node, property.id, property.name);\n            properties.push({\n                id: prop.id,\n                name: prop.name,\n                value: prop.value,\n            });\n        }\n        return properties;\n    });\n}\n/**\n * Returns a serialized node state specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function node_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        return {\n            node: node.save(),\n        };\n    });\n}\n/**\n * Sets width of progress bar.\n * If there is not run in progress, throws error.\n */\nexport function progress_change(params) {\n    const procedureInfo = runInfo.get(params.method);\n    if (!procedureInfo.inProgress) {\n        throw new Error('No run in progress');\n    }\n    if (!procedureInfo.progressBar)\n        throw new Error(`Progress bar does not exist for method: ${params.method}`);\n    if (params.progress === -1) {\n        procedureInfo.progressBar.classList.add('animate');\n        return;\n    }\n    if (params.progress > 100 || params.progress < 0)\n        throw new Error(`Progress has to be in [0, 100] or -1. Received: ${params.progress}`);\n    procedureInfo.progressBar.style.width = `${params.progress}%`;\n    procedureInfo.progressBar.classList.remove('animate');\n}\n/**\n * Updates the editor's metadata.\n */\nexport function metadata_change(params) {\n    editorManager.updateMetadata(params.metadata, true);\n}\n/**\n * Triggers action centering the editor.\n */\nexport function viewport_center() {\n    editorManager.baklavaView.editor.centerZoom();\n}\n/**\n * Creates new terminal instance\n */\nexport function terminal_add(params) {\n    const status = terminalStore.createTerminalInstance(params.name, params.readonly);\n    if (status === false) {\n        throw new Error(`Terminal instance of name '${params.name}' already exists`);\n    }\n}\n/**\n * Writes a single message to a chosen terminal\n */\nexport function terminal_write(params) {\n    if (!(params.name in terminalStore.logs)) {\n        terminalStore.createTerminalInstance(params.name);\n    }\n    terminalStore.add(params.message, params.name);\n}\nexport function notification_send(params) {\n    NotificationHandler.terminalLog(params.type, params.title, params.details);\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\nimport { JSONRPCServerAndClient, JSONRPCServer, JSONRPCClient, createJSONRPCErrorResponse, } from 'json-rpc-2.0';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport { io } from 'socket.io-client';\nimport NotificationHandler from '../notifications';\nimport { backendApiUrl } from '../utils';\nimport commonTypesSchema from '../../../../resources/api_specification/common_types.json' assert { type: 'json' };\nimport specificationSchema from '../../../../resources/api_specification/specification.json' assert { type: 'json' };\nimport * as remoteProcedures from './remoteProcedures';\nconst customMethodRegex = /^custom_.*$/;\nconst customMethodReplace = 'dataflow_run';\nclass CustomJSONRPCServerAndClient extends JSONRPCServerAndClient {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"customMethodRegex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"customMethodReplace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n    }\n}\nconst ajv = new Ajv2019({\n    schemas: [commonTypesSchema],\n    allowUnionTypes: true,\n    strict: true,\n});\nconst frontendEndpoints = specificationSchema.frontend_endpoints;\nconst backendEndpoints = specificationSchema.backend_endpoints;\nconst externalEndpoints = specificationSchema.external_endpoints;\n// This should become part of the testing suite at some point\nlet invalidDefinition;\ntry {\n    [frontendEndpoints, backendEndpoints, externalEndpoints].forEach((endpoints) => {\n        Object.entries(endpoints).forEach(([definitionName, definition]) => {\n            var _a;\n            invalidDefinition = definitionName;\n            ajv.compile(definition.params);\n            ajv.compile((_a = definition.returns) !== null && _a !== void 0 ? _a : {});\n        });\n    });\n}\ncatch (exception) {\n    throw new Error(`Procedures specification schema '${invalidDefinition}' is incorrect: ${exception}`);\n}\n/**\n * Middleware that validates received requests.\n */\nconst validateServerRequestResponse = (next, request, serverParams) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    // request validation\n    if (!(request.method in frontendEndpoints)) {\n        if (request.id !== undefined)\n            return createJSONRPCErrorResponse(request.id, 1, 'Requested method does not exist');\n        throw new Error('Requested method does not exist');\n    }\n    const schema = frontendEndpoints[request.method];\n    const valid = ajv.validate(schema.params, (_a = request.params) !== null && _a !== void 0 ? _a : {});\n    if (!valid) {\n        if (request.id !== undefined)\n            return createJSONRPCErrorResponse(request.id, 1, 'Request does not match specification');\n        throw new Error('Request does not match specification');\n    }\n    const response = yield next(request, serverParams);\n    if (request.id === undefined)\n        return null;\n    // response validation\n    if ((response === null || response === void 0 ? void 0 : response.result) !== undefined && schema.returns !== null) {\n        const validResponse = ajv.validate(schema.returns, response.result);\n        if (!validResponse) {\n            if (request.id !== undefined) {\n                return createJSONRPCErrorResponse(request.id, 1, 'Response does not match specification');\n            }\n            throw new Error('Response does not match specification');\n        }\n    }\n    return response;\n});\nlet jsonRPCID = 1;\n// eslint-disable-next-line no-plusplus\nconst createID = () => jsonRPCID++;\nconst commonHeaders = {\n    'Access-Control-Allow-Origin': 'http://localhost',\n    'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',\n};\nconst requestSchema = new Map();\nconst MAX_MESSAGE_LENGTH = 256 * 1024;\nlet socket;\nlet jsonRPCServer;\n/**\n * Function that creates JSON-RPC client-server and defines how messages are send and received.\n */\nfunction createServer() {\n    // Initialize SocketIO\n    if (!backendApiUrl)\n        return;\n    socket = io(backendApiUrl, {\n        extraHeaders: commonHeaders,\n    });\n    // Create JSON-RPC server\n    jsonRPCServer = new JSONRPCServerAndClient(new JSONRPCServer(), new JSONRPCClient((request) => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const method = (customMethodRegex.test(request.method)) ?\n            customMethodReplace : request.method;\n        // request validation\n        if (!(method in externalEndpoints) && !(method in backendEndpoints)) {\n            throw new Error('Requested method not known');\n        }\n        if (socket.disconnected) {\n            return Promise.reject(new Error('WebSocket is disconnected. Make sure the communication server is available.'));\n        }\n        const endpoints = (method in externalEndpoints) ?\n            externalEndpoints : backendEndpoints;\n        const schema = endpoints[method];\n        const valid = ajv.validate(schema.params, (_a = request.params) !== null && _a !== void 0 ? _a : {});\n        if (!valid)\n            return Promise.reject(new Error('Request does not match specification'));\n        if (request.id) {\n            requestSchema.set(request.id, schema);\n        }\n        // sending request\n        const endpoint = (endpoints === backendEndpoints) ? 'backend-api' : 'external-api';\n        const stringify = JSON.stringify(request);\n        try {\n            // Emit request in chunks\n            if (stringify.length > MAX_MESSAGE_LENGTH) {\n                const messageID = (_b = request.id) !== null && _b !== void 0 ? _b : crypto.randomUUID();\n                for (let i = 0; i < stringify.length; i += MAX_MESSAGE_LENGTH) {\n                    socket.emit(endpoint, {\n                        id: messageID,\n                        chunk: stringify.substring(i, Math.min(i + MAX_MESSAGE_LENGTH, stringify.length)),\n                        end: i + MAX_MESSAGE_LENGTH >= stringify.length,\n                    });\n                }\n                // Emit whole request\n            }\n            else {\n                socket.emit(endpoint, request);\n            }\n        }\n        catch (exception) {\n            return Promise.reject(exception);\n        }\n        return Promise.resolve();\n    }), createID));\n    // Add middlewares\n    jsonRPCServer.server.applyMiddleware(validateServerRequestResponse);\n    // Register JSON-RPC methods\n    Object.entries(remoteProcedures).forEach(([name, func]) => {\n        if (typeof (func) === 'function' && name in frontendEndpoints)\n            jsonRPCServer.addMethod(name, func);\n        else if (typeof (func) === 'function') {\n            NotificationHandler.showToast('warning', `Function ${name} was not registered as RPC method`);\n        }\n    });\n    // Define SocketIO events\n    socket.on('connect', () => NotificationHandler.terminalLog('info', 'Initialized connection with communication server', null));\n    socket.on('disconnect', () => {\n        NotificationHandler.terminalLog('warning', 'Connection with communication server disrupted', null);\n        jsonRPCServer.rejectAllPendingRequests('WebSocket disconnected');\n    });\n    socket.on('api', (data) => __awaiter(this, void 0, void 0, function* () {\n        const response = yield jsonRPCServer.server.receive(data);\n        if (response) {\n            try {\n                const ack = yield socket.emitWithAck('external-api', response);\n                if (ack !== undefined && !ack) {\n                    NotificationHandler.terminalLog('error', 'Response to external app was not send', null);\n                }\n            }\n            catch (error) {\n                NotificationHandler.terminalLog('error', `Response to ${data.method} request cannot be send`, error);\n            }\n        }\n    }));\n    socket.on('api-response', (response) => {\n        var _a;\n        // response validation\n        if (response.result && response.id && ((_a = requestSchema.get(response.id)) === null || _a === void 0 ? void 0 : _a.returns)) {\n            const validResponse = ajv.validate(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            requestSchema.get(response.id).returns, response.result);\n            if (!validResponse) {\n                jsonRPCServer.client.receive(createJSONRPCErrorResponse(response.id, 1, 'Response does not match specification'));\n                return;\n            }\n        }\n        jsonRPCServer.client.receive(response);\n    });\n    jsonRPCServer.customMethodRegex = customMethodRegex;\n    jsonRPCServer.customMethodReplace = customMethodReplace;\n}\nconst obj = {\n    get jsonRPC() {\n        if (!jsonRPCServer)\n            createServer();\n        return jsonRPCServer;\n    },\n};\nexport default obj.jsonRPC;\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JSONRPCErrorCode } from 'json-rpc-2.0';\nimport { charset } from 'mime-types';\nimport { backendApiUrl, PMMessageType, JSONRPCCustomErrorCode } from '../utils';\nimport jsonRPC from './rpcCommunication';\nimport runInfo from './runInformation';\nimport NotificationHandler from '../notifications';\nimport EditorManager from '../EditorManager';\n\n// Default external application capabilities\nconst defaultAppCapabilities = {};\n\n/**\n * Creates notifications based on response received from external application\n */\nfunction handleExternalAppResponse(response) {\n    // Status is HTTPCodes.OK so a message from the application is received.\n    if (response.type === PMMessageType.OK) {\n        NotificationHandler.terminalLog('info', response.content);\n    } else if (response.type === PMMessageType.ERROR) {\n        NotificationHandler.terminalLog('error', `Error occurred: ${response.content}`, response.content);\n    } else if (response.type === PMMessageType.WARNING) {\n        NotificationHandler.terminalLog('warning', `Warning: ${response.content}`, response.content);\n    }\n}\n\n/**\n * Creates notifications based on specifiation.\n * Returns `true` if error appeared.\n */\nfunction handleSpecificationResult({ errors, warnings }, errorTitle, warningTitle) {\n    if (Array.isArray(warnings) && warnings.length) {\n        NotificationHandler.terminalLog('warning', warningTitle, warnings);\n    }\n    if (Array.isArray(errors) && errors.length) {\n        NotificationHandler.terminalLog('error', errorTitle, errors);\n        return true;\n    }\n    return false;\n}\n\nconst startTimeoutStatusInterval = 1500;\n\nclass ExternalApplicationManager {\n    externalApplicationConnected = false;\n\n    backendAvailable = backendApiUrl !== null;\n\n    editorManager = EditorManager.getEditorManagerInstance();\n\n    idStatusInterval = null;\n\n    timeoutStatusInterval = startTimeoutStatusInterval;\n\n    appCapabilities = {};\n\n    /**\n     * Function that fetches state of the connection and updates\n     * `this.externalApplicationConnected` property.\n     */\n    async updateConnectionStatus() {\n        try {\n            const response = await jsonRPC.request('status_get');\n\n            // If the application was connected and the connection was lost, a warning is displayed.\n            if (!response.status.connected && this.externalApplicationConnected) {\n                NotificationHandler.terminalLog('warning', 'External application was disconnected');\n            }\n\n            // If external-app disconnects while running, the progress bar needs to be reset.\n            if (this.externalApplicationConnected !== response.status.connected) {\n                const progressBar = document.querySelector('.progress-bar');\n                progressBar.style.width = '0%';\n                runInfo.forEach((_v, k) => { runInfo.get(k).inProgress = false; });\n            }\n\n            this.externalApplicationConnected = response.status.connected;\n        } catch (error) {\n            this.externalApplicationConnected = false;\n        }\n    }\n\n    /**\n     * Event handler that asks the backend to open a TCP socket that can be connected to.\n     * If the external application did not connect the user is alertd with a feedback message.\n     * This function updates `this.externalApplicationConnected` property\n     *\n     * @returns {null | [string, string]} Null if the connection was successful, otherwise a tuple\n     * containing the toast type and the message.\n     */\n    async openTCP() {\n        try {\n            await jsonRPC.request('external_app_connect');\n            this.externalApplicationConnected = true;\n            return null;\n        } catch (error) {\n            this.externalApplicationConnected = false;\n            const errorCode = error.code ?? JSONRPCCustomErrorCode.EXCEPTION_RAISED;\n            const messageType = (errorCode !== JSONRPCCustomErrorCode.NEWER_SESSION_AVAILABLE) ? 'warning' : 'info';\n            return [messageType, error.message];\n        }\n    }\n\n    /**\n     * Event handler that asks the backend to send a dataflow specification.\n     * If the backend did not manage to send it the user is alerted with a feedback message.\n     * Otherwise the specification is passed to the editor that renders a new environment.\n     */\n    async requestSpecification() {\n        let message = 'Unknown error';\n        try {\n            const data = await jsonRPC.request('specification_get');\n\n            if (data.type === PMMessageType.OK) {\n                const specification = data.content;\n\n                if (handleSpecificationResult(\n                    EditorManager.validateSpecification(specification),\n                    'Warnings when validating specification',\n                    'Specification is invalid',\n                )) return;\n                const graph = this.editorManager.saveDataflow();\n                if (handleSpecificationResult(\n                    await this.editorManager.updateEditorSpecification(specification),\n                    'Warnings when loading specification',\n                    'Errors when loading specification',\n                )) return;\n                await this.editorManager.loadDataflow(graph, true);\n\n                NotificationHandler.terminalLog('info', 'Specification loaded successfully');\n            } else if (data.type === PMMessageType.WARNING) {\n                message = data.content;\n                NotificationHandler.terminalLog('warning', message);\n            } else if (data.type === PMMessageType.ERROR) {\n                message = data.content;\n                NotificationHandler.terminalLog('error', message);\n            }\n        } catch (error) {\n            message = error.message;\n            NotificationHandler.terminalLog('error', message);\n        }\n    }\n\n    /**\n    * Provides capabilities of the third-party app connected via server\n    * to Pipeline Manager's frontend.\n    */\n    async requestAppCapabilities() {\n        try {\n            const appCapabilities = await jsonRPC.request('app_capabilities_get');\n            this.appCapabilities = { ...defaultAppCapabilities, ...appCapabilities };\n        } catch (error) {\n            this.appCapabilities = { ...defaultAppCapabilities };\n            NotificationHandler.terminalLog('warning', 'Application capabilities cannot be retrieved, using defaults', error.message);\n        }\n    }\n\n    /**\n    * Handles dataflow export.\n    */\n    async requestDataflowExport() {\n        const dataflow = this.editorManager.saveDataflow();\n        if (!dataflow) return false;\n\n        let data;\n        try {\n            data = await jsonRPC.request('dataflow_export', { dataflow });\n        } catch (error) {\n            // The connection was closed\n            data = error.message;\n            NotificationHandler.terminalLog('error', data);\n            return false;\n        }\n\n        // Status is HTTPCodes.OK so a message from the application is received.\n        if (data.type === PMMessageType.OK) {\n            return data;\n        }\n\n        if (data.type === PMMessageType.ERROR) {\n            NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, data.content);\n        } else if (data.type === PMMessageType.WARNING) {\n            NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, data.content);\n        }\n        return false;\n    }\n\n    /**\n     * Event handler that loads a current dataflow from the editor and sends a request\n     * to the backend based on the action argument.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     */\n    async requestDataflowAction(procedureName) {\n        const dataflow = this.editorManager.saveDataflow();\n        const runProcedureInfo = runInfo.get(procedureName);\n        if (!dataflow) return;\n        const validatedProcedureName = (jsonRPC.customMethodRegex.test(procedureName)) ?\n            jsonRPC.customMethodReplace : procedureName;\n\n        if (validatedProcedureName === 'dataflow_run') {\n            if (runProcedureInfo.inProgress) {\n                NotificationHandler.showToast('error', 'Previous run has not finished, cannot process this request');\n                return;\n            }\n            NotificationHandler.showToast('info', 'Running dataflow');\n        }\n        runProcedureInfo.inProgress = true;\n\n        let data;\n        try {\n            if (validatedProcedureName.startsWith('dataflow_')) {\n                data = await jsonRPC.request(procedureName, { dataflow });\n            } else {\n                data = await jsonRPC.request(validatedProcedureName);\n            }\n        } catch (error) {\n            // The connection was closed\n            data = error.message;\n            NotificationHandler.terminalLog('error', 'Cannot create a request', data);\n            runProcedureInfo.inProgress = false;\n            return;\n        }\n\n        handleExternalAppResponse(data);\n        runProcedureInfo.inProgress = false;\n    }\n\n    /**\n     * Event handler that check if remote procedure is running and send stop request.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    async requestDataflowStop(procedureName) {\n        if (!runInfo.get(procedureName).inProgress) {\n            NotificationHandler.showToast('error', 'Nothing to stop, no ongoing jobs running');\n            return;\n        }\n\n        try {\n            const response = await jsonRPC.request('dataflow_stop', { method: procedureName });\n            handleExternalAppResponse(response);\n        } catch (error) {\n            NotificationHandler.terminalLog('error', error.message);\n        }\n    }\n\n    /**\n     * Event handler that loads a file and asks the backend to delegate this operation\n     * to the external application to parse it into the Pipeline Manager format\n     * so that it can be loaded into the editor.\n     * It the validation is successful it is loaded as the current dataflow.\n     * Otherwise the user is alerted with a feedback message.\n     *\n     * @param dataflow Dataflow to be impported\n     */\n    async importDataflow() {\n        const file = document.getElementById('request-dataflow-button').files[0];\n        if (!file) return;\n\n        const reader = new FileReader();\n        const encoding = charset(file.type);\n        const readerPromise = new Promise((resolve) => {\n            reader.onloadend = () => {\n                resolve(\n                    (encoding) ? reader.result : reader.result.replace(/data:.*;base64,/, ''),\n                );\n            };\n        });\n        // Read file as text if possible, otherwise return base64 string\n        if (encoding) {\n            reader.readAsText(file, encoding);\n        } else {\n            reader.readAsDataURL(file);\n        }\n        const dataflow = await readerPromise;\n        if (!dataflow) {\n            NotificationHandler.showToast('error', 'File cannot be loaded');\n            return;\n        }\n\n        try {\n            const data = await jsonRPC.request('dataflow_import', { external_application_dataflow: dataflow, mime: file.type, base64: !encoding });\n            if (data.type === PMMessageType.OK) {\n                const { errors, warnings } = await this.editorManager.loadDataflow(data.content);\n                if (Array.isArray(errors) && errors.length) {\n                    NotificationHandler.terminalLog('error', 'Dataflow is invalid', errors);\n                } else if (Array.isArray(warnings) && warnings.length) {\n                    NotificationHandler.terminalLog('warning', 'Dataflow imported with warning', warnings);\n                } else {\n                    NotificationHandler.showToast('info', 'Imported dataflow');\n                }\n            } else if (data.type === PMMessageType.ERROR) {\n                const message = data.content;\n                NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, message);\n            } else if (data.type === PMMessageType.WARNING) {\n                NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, 'Imported dataflow');\n            }\n        } catch (error) {\n            const data = error.message;\n            NotificationHandler.terminalLog('error', data);\n        }\n    }\n\n    /**\n     * Send information to external application about changed values (like nodes, connections,\n     * positions, properties).\n     *\n     * @param method Name of the JSON-RPC method.\n     * @param changedProperties Params of the send request, should contain changed values.\n     */\n    async notifyAboutChange(method, changedProperties) {\n        if (\n            this.backendAvailable && this.externalApplicationConnected &&\n            this.editorManager.notifyWhenChanged\n        ) {\n            try {\n                await jsonRPC.request(method, changedProperties);\n            } catch (error) {\n                NotificationHandler.terminalLog(\n                    'warning', 'Error when notifing about change', error.message,\n                );\n            }\n        }\n    }\n\n    /**\n     * Send information to external application about input received by writable terminal.\n     *\n     * @param terminal Name Name of the terminal\n     * @param message Input provided for the terminal\n     */\n    async requestTerminalRead(terminalName, message) {\n        if (!(\n            this.backendAvailable && this.externalApplicationConnected\n        )) {\n            return;\n        }\n        try {\n            await jsonRPC.request('terminal_read', { name: terminalName, message });\n        } catch (error) {\n            NotificationHandler.terminalLog('warning', 'Error when sending terminal input', error.message);\n        }\n    }\n\n    /**\n     * Function that is used by setInterval() to periodically check the status\n     * of the TCP connection. If the connection is not alive, then `initializeConnection`\n     * is invoked.\n     */\n    async checkConnectionStatus() {\n        while (this.interval) {\n            /* eslint-disable-next-line no-await-in-loop */\n            await this.updateConnectionStatus();\n            if (!this.externalApplicationConnected) {\n                runInfo.forEach((_v, k) => { runInfo.get(k).inProgress = false; });\n                /* eslint-disable-next-line no-await-in-loop */\n                await this.initializeConnection(false);\n            }\n            /* eslint-disable-next-line no-await-in-loop,no-promise-executor-return */\n            await new Promise((r) => setTimeout(r, this.timeoutStatusInterval));\n        }\n    }\n\n    /**\n     * Starts status checking.\n     */\n    startStatusInterval() {\n        if (this.idStatusInterval === null) {\n            this.interval = true;\n            this.idStatusInterval = this.checkConnectionStatus();\n        }\n    }\n\n    /**\n     * Function used to initialize connection with the external application and request\n     * specification. Should be called after DOM is created.\n     *\n     * It checks whether a connection is established.\n     * If it is then it just requests a specification.\n     * If it is not then it opens a TCP port, wait for the application to connect and then\n     * requests specification.\n     *\n     * @param checkConnection True if should check connection status beforehand. Used to reduce\n     * the number of requests if the status of the connection is known.\n     */\n    async initializeConnection(checkConnection = true) {\n        if (checkConnection) {\n            await this.updateConnectionStatus();\n        }\n\n        if (!this.externalApplicationConnected) {\n            do {\n                NotificationHandler.terminalLog(\n                    'info',\n                    `Trying to establish connection with external application`,\n                );\n\n                /* eslint-disable-next-line no-await-in-loop */\n                const message = await this.openTCP();\n\n                if (message !== null) {\n                    /* eslint-disable-next-line no-await-in-loop,no-promise-executor-return */\n                    await new Promise((r) => setTimeout(r, this.timeoutStatusInterval));\n                } else {\n                    NotificationHandler.terminalLog(\n                        'info',\n                        `External application connected successfully`,\n                    );\n                }\n            } while (!this.externalApplicationConnected);\n            this.timeoutStatusInterval = startTimeoutStatusInterval;\n        }\n        if (this.externalApplicationConnected) {\n            await Promise.all([\n                this.requestSpecification(),\n                this.requestAppCapabilities(),\n            ]);\n        }\n        if (this.externalApplicationConnected) {\n            try {\n                await jsonRPC.request('frontend_on_connect');\n            } catch (error) {\n                if (error.code !== JSONRPCErrorCode.MethodNotFound &&\n                    error.code !== JSONRPCCustomErrorCode.EXTERNAL_APPLICATION_NOT_CONNECTED) {\n                    NotificationHandler.terminalLog('warning', error.message, error.data);\n                }\n            }\n        }\n    }\n}\n\nlet externalApplicationManager;\n\nexport default function getExternalApplicationManager() {\n    if (!externalApplicationManager) externalApplicationManager = new ExternalApplicationManager();\n    return externalApplicationManager;\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Helper function that can be used to handle double clicks.\n *\n * @param {number} timer time window in which a callback can be fired\n * @param {function} callback event fired on double click\n * @returns event that should be applied to @pointerdown\n */\nexport default function doubleClick(timer, callback) {\n    const doubleClickTimer = timer;\n    let lastClickTime = -doubleClickTimer;\n\n    /* eslint-disable vue/no-mutating-props,no-param-reassign */\n    const onMouseDown = (ev) => {\n        if (Date.now() - lastClickTime < doubleClickTimer) {\n            callback(ev);\n        }\n        lastClickTime = Date.now();\n    };\n\n    return onMouseDown;\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable import/prefer-default-export */\n\n// Mouse position\nlet y = 0;\nlet h = 0;\n\n// Height setting callback\nlet setTerminalHeight;\n\nconst mouseMoveHandler = (e) => {\n    const { clientY } = e;\n    const navBarHeight = 61;\n\n    // Calculate mouse move\n    const dy = y - clientY;\n\n    // Prevent terminal overflow under nav bar\n    if (clientY > navBarHeight) {\n        setTerminalHeight(h + dy);\n    }\n};\n\nconst mouseUpHandler = () => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = '';\n};\n\nexport const mouseDownHandler = (setHeight) => (e) => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n    setTerminalHeight = setHeight;\n\n    y = e.clientY;\n\n    // Calculate height of terminal panel\n    const styles = window.getComputedStyle(terminalWrapper);\n    h = parseInt(styles.height, 10);\n\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = 'none';\n};\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Returns a prepared interface that is passed to baklava constructor\n *\n * @param io configuration of the interface\n * @param hidden whether th interface should be hidden. For example groups of interfaces\n * are hidden by default\n * @param {*} name custom name for the interface that should be used instead of the one coming\n * from `io`\n * @returns baklava interface constructor\n */\nfunction createInterface(io, hidden, name = undefined) {\n    const intf = {};\n    Object.assign(intf, io);\n\n    intf.name = name ?? io.name;\n    if (intf.type !== undefined) {\n        intf.type = typeof io.type === 'string' || io.type instanceof String ? [io.type] : io.type;\n    }\n    intf.componentName = 'NodeInterface';\n    intf.hidden = hidden;\n\n    // Readonly values used for detecting whether there were any changes to the interface\n    intf.originalSide = intf.side;\n    intf.originalSidePosition = intf.sidePosition;\n    return intf;\n}\n\n/**\n * Parses and validates interfaces passed in specification\n *\n * @param interfaces list of interfaces from specification that is going to be parsed\n * @param interfaceGroup determines whether `interfaces` are interface groups. If true the\n * additionally field `.interfaces` is parsed.\n * @returns parsed interfaces that can be passed to baklavajs if the interfaces were valid.\n * Otherwise an array of errors is returned.\n */\nfunction parseSingleInterfaces(interfaces, interfaceGroup = false) {\n    const errors = [];\n    const tempParsed = {\n        input: {},\n        inout: {},\n        output: {},\n    };\n\n    interfaces.forEach((io) => {\n        // Copy the interface to avoid modifying the original object\n        const tempIO = JSON.parse(JSON.stringify(io));\n\n        if (io.array !== undefined) {\n            const [left, right] = io.array;\n\n            for (let j = left; j < right; j += 1) {\n                const name = `${io.name}[${j}]`;\n                if (tempParsed[io.direction][name] !== undefined) {\n                    errors.push(\n                        `Interface named '${name}' of direction '${io.direction}' is a duplicate.`,\n                    );\n                }\n                tempIO.externalName = io.externalName ? `${io.externalName}[${j}]` : undefined;\n\n                // Copy the interface to avoid modifying the assigned object\n                tempParsed[io.direction][name] = JSON.parse(JSON.stringify(tempIO));\n            }\n        } else {\n            if (tempParsed[io.direction][io.name] !== undefined) {\n                errors.push(\n                    `Interface named '${io.name}' of direction '${io.direction}' is a duplicate.`,\n                );\n            }\n            tempParsed[io.direction][io.name] = tempIO;\n        }\n\n        if (interfaceGroup) {\n            const newInterfaces = [];\n\n            tempIO.interfaces.forEach((buildingIO) => {\n                if (buildingIO.array !== undefined) {\n                    const [left, right] = buildingIO.array;\n\n                    for (let j = left; j < right; j += 1) {\n                        const name = `${buildingIO.direction}_${buildingIO.name}[${j}]`;\n                        newInterfaces.push(name);\n                    }\n                } else {\n                    const name = `${buildingIO.direction}_${buildingIO.name}`;\n                    newInterfaces.push(name);\n                }\n            });\n            tempIO.interfaces = newInterfaces; // eslint-disable-line no-param-reassign\n        }\n    });\n\n    // Removing inout with duplicate names\n    const filteredTempInouts = Object.fromEntries(\n        Object.entries(tempParsed.inout).filter(([name, state]) => {\n            const duplicate =\n                Object.keys(tempParsed.output).includes(name) ||\n                Object.keys(tempParsed.input).includes(name);\n            if (duplicate) {\n                errors.push(\n                    `Interface named '${name}' of direction '${state.direction}' ` +\n                        `is a duplicate. There already exists an input or output of this name.`,\n                );\n            }\n            return !duplicate;\n        }),\n    );\n\n    tempParsed.inout = filteredTempInouts;\n    tempParsed.input = { ...tempParsed.input, ...tempParsed.inout };\n    delete tempParsed.inout;\n\n    tempParsed.input = Object.fromEntries(\n        Object.entries(tempParsed.input).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n    tempParsed.output = Object.fromEntries(\n        Object.entries(tempParsed.output).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return tempParsed;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list tuples that have information about conflicting interfaces.\n */\nexport function validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs) {\n    const errors = [];\n    // Checking for integrity of interface groups\n    const usedInterfaces = new Set();\n\n    enabledInterfaceGroups.forEach((name) => {\n        const interfaces = inputs[name]?.interfaces ?? outputs[name]?.interfaces;\n        const groupDirection = name.slice(0, name.indexOf('_'));\n        const groupName = name.slice(name.indexOf('_') + 1);\n\n        interfaces.forEach((intfName) => {\n            if (usedInterfaces.has(intfName)) {\n                const intfDirection = intfName.slice(0, intfName.indexOf('_'));\n                const parsedIntfName = intfName.slice(intfName.indexOf('_') + 1);\n\n                errors.push([parsedIntfName, intfDirection, groupName, groupDirection]);\n            } else {\n                usedInterfaces.add(intfName);\n            }\n        });\n    });\n    return errors;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list of explicit errors.\n */\nexport function validateInterfaceGroups(enabledInterfaceGroups, inputs, outputs) {\n    const errors = validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs);\n    const errorMessages = [];\n\n    errors.forEach(([parsedIntfName, intfDirection, groupName, groupDirection]) => {\n        errorMessages.push(\n            `Interface of name '${parsedIntfName}' and direction '${intfDirection}' has been reused ` +\n                `by interface group named '${groupName}' of direction '${groupDirection}'. ` +\n                `Make sure your interface groups are disjoint.`,\n        );\n    });\n\n    return errorMessages;\n}\n\n/**\n *\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns inputs and outputs of the nodes with `sidePositions` assigned if\n * there were no errors found. Otherwise a list of errors is returned.\n */\nexport function applySidePositions(inputs, outputs) {\n    const tempParsedSides = {\n        left: {},\n        right: {},\n    };\n\n    const errors = [];\n\n    // Dividing interfaces into left and right sides\n    Object.entries({ ...inputs, ...outputs }).forEach(([name, intf]) => {\n        if (intf.side === 'right' || (intf.side === undefined && intf.direction === 'output')) {\n            tempParsedSides.right[name] = { ...intf };\n            tempParsedSides.right[name].side = 'right';\n        } else if (intf.side === 'left' || (intf.side === undefined && (intf.direction === 'input' || intf.direction === 'inout'))) {\n            tempParsedSides.left[name] = { ...intf };\n            tempParsedSides.left[name].side = 'left';\n        }\n    });\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    // validating and setting sidePositions\n    const occupiedInputSidePositions = new Set();\n    const occupiedOutputSidePositions = new Set();\n\n    Object.entries(tempParsedSides.left).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedInputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedInputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedOutputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedOutputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    let leftSidePositionIndex = 0;\n    let rightSidePositionIndex = 0;\n\n    const getLeftSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedInputSidePositions.has(leftSidePositionIndex)) {\n                leftSidePositionIndex += 1;\n            }\n            occupiedInputSidePositions.add(leftSidePositionIndex);\n            return leftSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    const getRightSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedOutputSidePositions.has(rightSidePositionIndex)) {\n                rightSidePositionIndex += 1;\n            }\n            occupiedOutputSidePositions.add(rightSidePositionIndex);\n            return rightSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    Object.entries(tempParsedSides.left).forEach(([, intf]) => {\n        intf.sidePosition = getLeftSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([, intf]) => {\n        intf.sidePosition = getRightSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    return {\n        inputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction === 'input' || intf.direction === 'inout'),\n        ),\n        outputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction === 'output'),\n        ),\n    };\n}\n\n/**\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} interfaceGroups Object describing groups of interfaces'\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that are enabled\n * @returns object that has inputs and outputs key if parsing was successful,\n * a list of errors otherwise.\n */\nexport function parseInterfaces(\n    interfaces,\n    interfaceGroups,\n    defaultInterfaceGroups,\n) {\n    let errors = [];\n\n    // Parsing single interfaces first\n    const tempParsed = parseSingleInterfaces(interfaces);\n\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsed) && tempParsed.length) {\n        return tempParsed;\n    }\n\n    // Checking for integrity of interface groups\n    interfaceGroups.forEach((intfG) => {\n        intfG.interfaces.forEach((intf) => {\n            if (intf.array !== undefined) {\n                const [left, right] = intf.array;\n\n                for (let j = left; j < right; j += 1) {\n                    const name = `${intf.direction}_${intf.name}[${j}]`;\n                    if (\n                        !Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)\n                    ) {\n                        errors.push(\n                            `Interface named '${intf.name}[${j}]' of direction '${intf.direction}' ` +\n                                `used for interface group '${intfG.name}' of direction ` +\n                                `'${intfG.direction}' does not exist.`,\n                        );\n                    }\n                }\n            } else {\n                const name = `${intf.direction}_${intf.name}`;\n                if (!Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)) {\n                    errors.push(\n                        `Interface named '${intf.name}' of direction '${intf.direction}' ` +\n                            `used for interface group '${intfG.name}' of direction ` +\n                            `'${intfG.direction}' does not exist.`,\n                    );\n                }\n            }\n        });\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    const tempParsedGroups = parseSingleInterfaces(interfaceGroups, true);\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsedGroups) && tempParsedGroups.length) {\n        return tempParsedGroups;\n    }\n\n    // All interfaces that create some interfaces groups\n    const interfacesCreatingGroups = new Set();\n    Object.values({\n        ...tempParsedGroups.input,\n        ...tempParsedGroups.output,\n    }).forEach((state) => {\n        state.interfaces.forEach((intf) => interfacesCreatingGroups.add(intf));\n    });\n\n    // Detecting integrity of enabled interface groups\n    const enabledInterfaceGroupsNames = defaultInterfaceGroups.map(\n        (group) => `${group.direction}_${group.name}`,\n    );\n\n    errors = validateInterfaceGroups(\n        enabledInterfaceGroupsNames,\n        { ...tempParsedGroups.input, ...tempParsed.input },\n        { ...tempParsedGroups.output, ...tempParsed.output },\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    // Interfaces that belong to groups are removed as they should not have side\n    // positions applied as they are never rendered\n    tempParsed.input = Object.fromEntries(Object.entries(tempParsed.input).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    tempParsed.output = Object.fromEntries(Object.entries(tempParsed.output).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    const parsedSides = applySidePositions(\n        { ...tempParsed.input, ...tempParsedGroups.input },\n        { ...tempParsed.output, ...tempParsedGroups.output },\n    );\n    if (Array.isArray(parsedSides) && parsedSides.length) {\n        return parsedSides;\n    }\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    const createdInterfaces = {\n        inputs: {},\n        outputs: {},\n    };\n\n    // Filtering single interfaces that are part of interface groups\n    // Those interfaces are removed as they are never rendered\n    // This is only used when parsing a specification format\n    Object.entries(parsedSides.inputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    Object.entries(parsedSides.outputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    return createdInterfaces;\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Handles incoming notifications from Pipeline Manager: creates toast\n * notifications (popup), adds them to store for notifications panel,\n * logs appropriate notification to terminal window\n */\n\nimport { createToastInterface, POSITION } from 'vue-toastification';\nimport { notificationStore, terminalStore } from './stores.js';\nimport Notification from '../components/Notification.vue';\nimport EditorManager from './EditorManager';\n\nconst toast = createToastInterface({\n    timeout: 5000,\n    position: POSITION.BOTTOM_RIGHT,\n    icon: false,\n    closeButton: false,\n});\n\nexport const LOG_LEVEL = {\n    info: 0,\n    warning: 1,\n    error: 2,\n};\n\nexport default class NotificationHandler {\n    static NotificationHandler = true;\n\n    static defaultShowOption = true;\n\n    /**\n     * Sets the showNotification flag. If set to false, no popup\n     * notifications are shown\n     *\n     * @param show new value for showNotification\n     */\n    static setShowNotification(show) {\n        NotificationHandler.showNotifications = show;\n    }\n\n    /**\n     * Sets the default showNotification flag value.\n     * Does not change whether the notifications are actually set or not,\n     * this should be done in `setShowNotification` or `restoreShowNotification`\n     * methods\n     *\n     * @param showOption default value for showNotification flag\n     */\n    static setShowOption(showOption) {\n        NotificationHandler.defaultShowOption = showOption;\n    }\n\n    /**\n     * Restores show notification flag to it's default value\n     */\n    static restoreShowNotification() {\n        NotificationHandler.showNotifications = NotificationHandler.defaultShowOption;\n    }\n\n    static showToast(type, message) {\n        const content = {\n            component: Notification,\n            props: {\n                type,\n                message,\n            },\n        };\n\n        if (\n            LOG_LEVEL[type] >= LOG_LEVEL[\n                EditorManager.getEditorManagerInstance().baklavaView.logLevel?.toLowerCase()\n            ] && NotificationHandler.showNotifications\n        ) {\n            toast(content);\n        } else {\n            const bell = document.querySelector('#navbar-bell>.indicator');\n            if (bell) {\n                bell.classList.remove('animate');\n                setTimeout(() => bell.classList.add('animate'), 300);\n            }\n        }\n        notificationStore.add({ type, message });\n    }\n\n    /**\n     * Helper function that displays the title of the message as a toast notification and\n     * a full message in terminal with a proper title.\n     *\n     * @param {string} type Type of the toast notification\n     * @param {string} title Title of the message used both for toast and terminal notification.\n     * Preferably without any punctuation marks at the end\n     * @param {Array[string] | string | undefined} messages messages that are displayed in\n     * the terminal\n     */\n    static terminalLog(type, title, messages) {\n        NotificationHandler.showToast(type, title);\n        terminalStore.addParsed(title, messages);\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { reactive } from 'vue';\n\nconst storageAvailable = (() => {\n    try {\n        const randomKey = Math.random().toString(36);\n        const randomValue = Math.random().toString(36);\n        localStorage.setItem(randomKey, randomValue);\n        localStorage.removeItem(randomKey);\n        return true;\n    } catch {\n        return false;\n    }\n})();\n\nconst pmStorage = new Map();\nconst get = (key) => {\n    if (storageAvailable) return localStorage.getItem(key);\n    return pmStorage.get(key) ?? null;\n};\n\nconst set = (key, value) => {\n    if (storageAvailable) localStorage.setItem(key, value);\n    else pmStorage.set(key, value);\n};\n\nconst remove = (key) => {\n    if (storageAvailable) localStorage.removeItem(key);\n    else pmStorage.delete(key);\n};\n\n/* eslint-disable import/prefer-default-export */\nexport const notificationStore = reactive({\n    notifications: JSON.parse(get('notifications')) || [],\n    add(notification) {\n        this.notifications.push(notification);\n\n        set('notifications', JSON.stringify(this.notifications));\n    },\n\n    remove() {\n        remove('notifications');\n        this.notifications = [];\n    },\n\n    removeOne(index) {\n        const newNotifications = this.notifications.filter((_, idx) => index !== idx);\n\n        set('notifications', JSON.stringify(newNotifications));\n        this.notifications = newNotifications;\n    },\n});\n\nexport const MAIN_TERMINAL = 'Terminal';\n\nexport const terminalStore = reactive({\n    // Object\n    logs: {\n        Terminal: JSON.parse(get(`logs`)) || [],\n    },\n    readOnly: {\n        Terminal: true,\n    },\n    add(log, instance = MAIN_TERMINAL) {\n        this.logs[instance].push(log);\n\n        // Update localStorage only for the main terminal\n        if (instance === MAIN_TERMINAL) {\n            set(`logs`, JSON.stringify(this.logs[instance]));\n        }\n    },\n    isReadOnly(instance = MAIN_TERMINAL) {\n        return this.readOnly[instance];\n    },\n\n    /**\n     * Adds a parsed notification. If there are messages, then it returns a following message:\n     *\n     * Title:\n     *     message_first_line\n     *     message_second_line\n     *     ...\n     *     message_last_line\n     *\n     * Otherwise, if messages are empty, then it returns a following message:\n     *\n     * Title.\n     *\n     * @param {string} title title of the message\n     * @param {Array[string] | string | undefined} messages messages of the message\n     */\n    addParsed(title, messages, instance = MAIN_TERMINAL) {\n        let parsedMessage = title;\n        if (messages) {\n            if (typeof messages === 'string' || messages instanceof String) {\n                messages = [messages]; // eslint-disable-line no-param-reassign\n            }\n            parsedMessage += ':';\n\n            messages.forEach((message) => {\n                parsedMessage += '\\n';\n                parsedMessage += '    ';\n                parsedMessage += message;\n            });\n        } else {\n            parsedMessage += '.';\n        }\n        this.add(parsedMessage, instance);\n    },\n\n    remove(instance = MAIN_TERMINAL) {\n        if (instance === MAIN_TERMINAL) {\n            remove(`logs`);\n        }\n        this.logs[instance] = [];\n    },\n\n    /**\n     * Creates a new terminal instance.\n     * If such terminal already exisists, then false is returned.\n     *\n     * @param {string} Unique name of the terminal instance to be created.\n     * @param {boolean} If true, then the terminal instance will be only for read.\n     * @returns returns true if terminal was created, false otherwise.\n     */\n    createTerminalInstance(name, readOnly = true) {\n        if (Object.keys(this.logs).includes(name)) return false;\n\n        this.logs[name] = [];\n        this.readOnly[name] = readOnly;\n        return true;\n    },\n});\n"],"names":["suppressingHistory","transactionId","Step","constructor","type","topic","tid","Object","defineProperty","this","enumerable","configurable","writable","value","add","graph","Error","remove","NodeStep","super","undefined","nodeTuple","addNode","load","node","nodes","find","n","id","save","removeNode","ConnectionStep","conn","fromNode","findNodeById","from","nodeId","toNode","to","values","inputs","outputs","filter","iface","port","connAdded","addConnection","connections","removeConnection","AnchorStep","anchor","anchors","splice","suppressHistoryLogging","startTransaction","commitTransaction","useHistory","commandHandler","token","Symbol","history","Map","undoneHistory","currentId","oldId","unsubscribeFromGraphEvents","g","tok","events","unsubscribe","addAnchor","removeAnchor","graphSwitch","newGraph","oldGraph","copyStateStack","get","set","undoneItem","historyItem","subscribe","push","toString","step","_a","inTransaction","slice","reverse","forEach","emit","indexOf","tuple","idx","Math","trunc","flush","immediate","singleStepTransaction","mainHistory","auxiliaryHistory","pop","length","selectedNodes","registerCommand","canExecute","execute","registerHotkey","max_steps","RunInfo","procedureName","progressBar","document","querySelector","inProgress","pr_inProgress","classList","style","width","hook","DefaultMap","defaultFactory","key","has","arguments","newValue","setHook","v","ir","clearRegistry","exposedInterfaces","clear","pushGraphIdToRegistry","intfId","graphId","sharedInterface","graphIds","createSharedInterface","intf","maxConnectionsCount","connectionCount","isRegistered","getRegisteredInterface","deleteRegisteredInterface","delete","registerInterface","sharedInterfaceGraphId","gridSnapper","movementStep","coord","round","nodeSnapper","kind","selectedNodesIds","nearestCoords","includes","map","position","otherCoords","abs","min","COPY_COMMAND","DELETE_COMMAND","UNHIGHLIGHT_COMMAND","PASTE_COMMAND","BaklavaInterfaceTypes","types","defaultStyle","interfaceConnectionPattern","interfaceConnectionColor","interfaceColor","viewPlugin","hooks","renderInterface","el","firstType","normalizeType","t","color","arrow","backgroundColor","greyArrow","getComputedStyle","getPropertyValue","String","getConnectionStyle","fromTypes","toTypes","commonTypes","Array","isArray","readInterfaceTypes","metadata","interfaces","entries","io","name","nodeBottomPoint","connection","scaling","panning","nodeHtml","getElementById","offsetTop","offsetHeight","y","calculateEllipseR","x","cx","cy","slope","sqrt","NormalizedConnection","x1","y1","x2","y2","direction","ConnectionRenderer","viewModel","randomizedOffset","getShift","ncFrom","ncTo","shiftIndex","sidePosition","fromNodeNeighbours","c","side","toNodeNeighbours","reduce","accumulator","char","charCodeAt","curvedRender","nc","dx","rightmost","max","leftmost","curvedRenderLoopback","displayedGraph","sideMargin","shift","leftRx","leftRy","renderingSide","leftx","rightx","lefty","righty","bottomY","rightCx","rightCy","rightRx","rightRy","bottomCx","bottomCy","bottomRx","bottomRy","leftCx","leftCy","orthogonalRender","a","path","offset","minMargin","middlePoint","mid","firstTurn","lastTurn","orthogonalRenderLoopback","xShift","render","loopback","isLoopback","Specification","static","currentSpecification","unresolvedSpecification","instance","getNodeSpecification","nodeName","startsWith","graphs","Metadata","state","default","DEFAULT_GRAPH_NODE_CATEGORY","DEFAULT_GRAPH_NODE_NAME","DEFAULT_GRAPH_NODE_TYPE","async","loadJsonFromRemoteLocation","customLocation","location","loc","relativeurl","href","split","join","jsonsubs","VUE_APP_JSON_URL_SUBSTITUTES","subs","JSON","parse","parts","substring","specifiedUrl","keys","replace","parseLocation","fetchedContent","fetch","mode","error","message","json","EditorManager","defaultMetadata","editor","baklavaView","specificationLoaded","specification","getInstance","updatedMetadata","unregisterNodes","connectionRenderer","connectionStyle","layoutManager","useAlgorithm","layout","interfaceTypes","layers","collapseSidebar","allowLoopbacks","navbarItems","cache","logLevel","specificationVersion","clipboard","nodeBuffer","connectionBuffer","consecutivePasteNumber","isEmpty","findInterface","i","readonly","interfacesOfSelectedNodes","flatMap","stringify","_b","idmap","parsedNodeBuffer","parsedConnectionBuffer","newNodes","newConnections","executeCommand","nodeType","subgraph","nodeTypes","copiedNode","beforeLoad","nodeState","ns","graphState","mapNewId","obj","newId","assignNewIds","subNode","externalName","resolveNewExposedName","assign","graphNode","updateExposedInterfaces","fromId","toId","fromIntf","toIntf","newConnection","useClipboard","dataflowSpecification","lazyLoad","jsonlint","errors","warnings","clearEditorManagerState","version","globalVisitedSpecs","Set","includeErrors","downloadNestedImports","includeGraphs","includeGraphsErrors","updateMetadata","newErrors","newWarnings","updateGraphSpecification","unregisterGraphs","deepCleanEditor","trace","specificationAndTrace","currentImports","include","Promise","all","specificationUrl","status","val","spec","specTrace","newSpecification","mergeObjects","size","dataflows","dataflow","url","dataflowMetadata","targetGraph","category","resolvedNodes","preprocessedNodes","preprocessNodes","resolveInheritance","e","validateResolvedSpecification","extends","eName","extended","extending","siblings","myNode","NodeFactory","layer","properties","interfaceGroups","defaultInterfaceGroups","twoColumn","description","registerNodeType","title","isCategory","icon","nodeIcons","baseName","suffix","baseUrl","baseIconUrls","urls","urlName","nodeURLs","myGraph","addGraphTemplate","graphToValidate","prototype","hasOwnProperty","call","loadingErrors","loadingWarnings","loadDataflow","warning","uniqueWarnings","at","overriding","loading","newMetadata","baseURLs","icons","iconName","hideHud","settings","background","gridSize","backgroundSize","ignoredLayers","unsortedNodes","isObject","mergeNodes","child","base","output","structuredClone","baseNames","fromEntries","index","override","recurrentMerge","abstract","saveSpecification","saveDataflow","currVal","m","dm","preventCentering","loadOnly","notifyWhenChanged","validationErrors","validateDataflow","validateMetadata","err","primaryObject","secondaryObject","data","schema","additionalAjvOptions","ajv","allowUnionTypes","formats","hex","schemas","addKeyword","validate","compile","isTextFormat","dataJSON","exception","$id","instancePath","errorPrefix","result","lineStart","pointers","line","lineEnd","valueEnd","keyword","params","allowedValues","additionalProperty","allowedValue","unevaluatedProperty","validateSpecification","categoryNodes","definedCategories","nodeNames","categories","categoryNodeName","remainingCategories","extendedNode","commonPrefix","validateJSONWithSchema","jsonmetadata","isInsideSubgraph","returnFromSubgraph","backFromSubgraph","updateSubgraphName","updateCurrentSubgraphName","BaseLayoutEngine","availableAlgorithms","chooseAlgorithm","algorithm","activeAlgorithm","BaseLayoutAlgorithm","CytoscapeLayoutEngine","cytoscapeGraph","elements","height","edges","source","target","selector","shape","styleEnabled","options","boundingBox","w","h","avoidOverlapPadding","nodeOverlap","idealEdgeLength","edge","nodeSpacing","ranker","nodeSep","rankSep","run","promiseOn","NoLayoutAlgorithm","calculate","LayoutManager","layoutEngine","usedAlgorithm","availableEngines","NoLayout","CytoscapeEngine","engineName","algorithmName","getAvailableAlgorithms","engine","flat","registerGraph","interfaceToNodeId","dataflowToGraph","updateDimensions","idToPosition","graphToDataflow","runEngine","HTMLelement","offsetWidth","parseProperties","parsedProperties","usedNames","prop","group","parsedGroup","pgroupname","realname","parseNodeState","newState","out","enabledInterfaceGroups","instanceName","parsed","nodeExtends","nodeExtending","nodeSiblings","parsedInterfaces","createBaklavaInterface","baklavaIntf","createdProperties","getIntf","p","hidden","propName","propType","propDef","setPort","componentName","toLowerCase","BigInt","NaN","it","element","dtype","console","tempProperties","pname","groupedProperty","pgroup","createProperties","onCreate","parentSave","parentLoad","toggleInterfaceGroup","visible","graphInstance","savedState","newProperties","newInterfaces","ioName","ioState","updateInterfaces","stateInputs","stateOutputs","k","removeInput","idA","intfA","foundIntf","idB","intfB","addInterface","removeOutput","updateProperties","stateProperties","propA","baklavaProp","addInput","parsedState","parsedValue","propertyType","checkType","items","mismatchedElements","groupName","detectDiscrepancies","groupState","occupied","left","right","stateios","refreshSidePositions","maxposition","onDestroy","event","updateSubgraphInterfaces","INTERFACE_PREFIXES","exposedIntf","some","prefix","countedIntfNames","create","externalInterfaces","errorMessages","container","findIndex","newInterfacesPositionsOrErrors","GraphFactory","backendApiUrl","window","protocol","PMMessageType","OK","ERROR","PROGRESS","WARNING","editorManager","getGraph","graph_id","getNode","node_id","getProperty","graph_get","properties_change","property","new_value","position_change","nodes_change","added","info","deleted","remove_with_connections","removeNodeOnly","connections_change","findNodeInterface","getConnection","graph_change","properties_get","node_get","progress_change","procedureInfo","method","progress","metadata_change","viewport_center","centerZoom","terminal_add","terminal_write","notification_send","details","customMethodRegex","customMethodReplace","strict","frontendEndpoints","backendEndpoints","externalEndpoints","invalidDefinition","endpoints","definitionName","definition","returns","validateServerRequestResponse","next","request","serverParams","createJSONRPCErrorResponse","response","jsonRPCID","createID","commonHeaders","requestSchema","MAX_MESSAGE_LENGTH","socket","jsonRPCServer","jsonRPC","extraHeaders","JSONRPCServerAndClient","JSONRPCServer","JSONRPCClient","test","disconnected","reject","endpoint","messageID","crypto","randomUUID","chunk","end","resolve","server","applyMiddleware","func","addMethod","on","rejectAllPendingRequests","receive","ack","emitWithAck","client","createServer","defaultAppCapabilities","handleExternalAppResponse","content","handleSpecificationResult","errorTitle","warningTitle","ExternalApplicationManager","externalApplicationConnected","backendAvailable","idStatusInterval","timeoutStatusInterval","appCapabilities","connected","_v","code","updateEditorSpecification","runProcedureInfo","validatedProcedureName","file","files","reader","FileReader","encoding","charset","readerPromise","onloadend","readAsText","readAsDataURL","external_application_dataflow","mime","base64","changedProperties","terminalName","interval","updateConnectionStatus","initializeConnection","r","setTimeout","startStatusInterval","checkConnectionStatus","checkConnection","openTCP","requestSpecification","requestAppCapabilities","JSONRPCErrorCode","externalApplicationManager","getExternalApplicationManager","doubleClick","timer","callback","doubleClickTimer","lastClickTime","ev","Date","now","setTerminalHeight","mouseMoveHandler","clientY","mouseUpHandler","terminalWrapper","removeEventListener","mouseDownHandler","setHeight","styles","parseInt","addEventListener","createInterface","originalSide","originalSidePosition","parseSingleInterfaces","interfaceGroup","tempParsed","input","inout","tempIO","array","j","buildingIO","filteredTempInouts","duplicate","validateInterfaceGroupsNames","usedInterfaces","groupDirection","intfName","intfDirection","parsedIntfName","validateInterfaceGroups","applySidePositions","tempParsedSides","stripName","occupiedInputSidePositions","occupiedOutputSidePositions","leftSidePositionIndex","rightSidePositionIndex","getLeftSidePos","getRightSidePos","parseInterfaces","intfG","tempParsedGroups","interfacesCreatingGroups","enabledInterfaceGroupsNames","parsedSides","createdInterfaces","toast","timeout","closeButton","LOG_LEVEL","NotificationHandler","show","showNotifications","showOption","defaultShowOption","component","props","bell","messages","showToast","storageAvailable","randomKey","random","randomValue","localStorage","setItem","removeItem","pmStorage","getItem","notificationStore","notifications","notification","removeOne","newNotifications","_","MAIN_TERMINAL","terminalStore","logs","Terminal","readOnly","log","isReadOnly","addParsed","parsedMessage","createTerminalInstance"],"sourceRoot":""}